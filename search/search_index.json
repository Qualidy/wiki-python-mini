{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Python Einsteiger Schulung","text":"<ul> <li> Installation</li> <li> Variablen</li> <li> Bedingter Code</li> <li> Codewiederholung</li> <li> Collections</li> <li> Funktionen</li> <li> Unit Tests</li> <li> Projekt</li> <li> Quiz</li> </ul> <p>Schneller Navigieren</p> <p>P oder , : Zur vorherigen Seite gehen (Previous)</p> <p>N oder . : Zur n\u00e4chsten Seite gehen (Next)</p> <p></p>"},{"location":"content/bedingter_code/bedingter_code/","title":"Bedingter Code","text":"Video <p>Mit dem <code>if</code> Keyword und Einr\u00fcckungen kann man festlegen, dass Code nur unter bestimmten Bedingungen ausgef\u00fchrt wird.</p> <pre><code>name = input(\"Wie ist dein Name?\") # (1)!\nif 'q' in name: # (2)!\n    print(\"Wow, das ist ja ein seltener Name!\") # (3)!\nprint(f\"Auf jeden Fall ist dein Name {name}\") # (4)!\n</code></pre> <ol> <li>Der Nutzer wird nach seinem Namen gefragt. Die Eingabe wird in der Variable <code>name</code> gespeichert.</li> <li>Es wird gepr\u00fcft, ob der Buchstabe <code>'q'</code> in <code>name</code> auftaucht.</li> <li>Wenn <code>'q'</code> in <code>name</code> auftaucht, wird der einger\u00fcckte Code ausgef\u00fchrt. Hier k\u00f6nnen auch noch mehr Zeilen einger\u00fcckter Code stehen, die nur ausgef\u00fchrt werden, wenn die Bedingung erf\u00fcllt ist.</li> <li>Diese Zeile ist nicht einger\u00fcckt und wird daher auf jeden Fall wieder ausgef\u00fchrt.</li> </ol> <p>Code im Debugger ansehen</p> <p>Wenn die Bedingung, die neben dem <code>if</code> steht, wahr ist, dann werden die n\u00e4chsten Zeilen Code, die einger\u00fcckt sind, ausgef\u00fchrt. Wenn die Bedingung aber falsch ist, werden die einger\u00fcckten Zeilen einfach \u00fcbersprungen.</p> Bedingung einf\u00fcgen <p>Ersetze die <code>...</code> im folgenden Code so, dass zun\u00e4chst gepr\u00fcft wird, ob die in <code>alter</code> gespeicherte Zahl kleiner als <code>18</code> ist und man dann eine Abfuhr erh\u00e4lt. Danach soll gepr\u00fcft werden, ob das <code>alter</code> gr\u00f6\u00dfer oder gleich <code>18</code> ist  und man wird reingelassen:</p> <pre><code>alter = int(input(\"Wie alt bist du?\"))\n\n... alter &lt; 18:\n    print(\"Dieser Film ist nichts f\u00fcr dich!\")\n\n... alter &gt;= 18:\n    print(\"Du darfst rein.\")\n</code></pre> L\u00f6sung L\u00f6sungsvideo <p> </p> <pre><code>alter = int(input(\"Wie alt bist du?\"))\n\nif alter &lt; 18:\n    print(\"Dieser Film ist nichts f\u00fcr dich!\")\n\nif alter &gt;= 18:\n    print(\"Du darfst rein\")\n</code></pre>"},{"location":"content/bedingter_code/bedingung/","title":"Was ist eine Bedingung?","text":"Video <p>Eine Bedingung ist ein Ausdruck, der schlie\u00dflich zu einem booleschen Wert <code>True</code> oder <code>False</code> ausgewertet wird. Solche Bedingungen k\u00f6nnen wir leicht verstehen, indem wir sie laut vorlesen.</p> <pre><code>a = int(input(\"Gebe eine Ganzzahl ein:\"))\n\nprint(\"a ist kleiner als 5:\")\nprint(a &lt; 5)\n\nprint(\"a ist gr\u00f6\u00dfer als 10:\")\nprint(a &gt; 10)\n\nprint(\"a ist gr\u00f6\u00dfer als 1 und kleiner oder gleich 4:\")\nprint(1 &lt; a &lt;= 4)\n\nprint(\"x in Hallo\")\nprint(\"x\" in \"Hallo\")\n\nprint(\"a in Hallo\")\nprint(\"a\" in \"Hallo\")\n</code></pre> <p>Hier ist eine Liste mit den wichtigsten Operatoren f\u00fcr uns:</p> Operator Name <code>==</code> Gleich <code>!=</code> Ungleich <code>&gt;</code> (echt) Gr\u00f6\u00dfer als <code>&lt;</code> (echt) Kleiner als <code>&gt;=</code> Gr\u00f6\u00dfer oder gleich <code>&lt;=</code> Kleiner oder gleich <code>in</code> ist enthalten Boolsche Werte voraussagen <p>Sage voraus, was auf der Konsole ausgegeben wird, wenn das Programm ausgef\u00fchrt wird.</p> <pre><code>a = 3\nb = 5\n\nprint(a &gt; 5)\nprint(b &lt;= 5)\nprint(a + b &gt;= 5)\nprint(a &gt; b)\nprint(a + 2 == b)  \nprint(a)\nprint(b)\n</code></pre> L\u00f6sung L\u00f6sungsvideo <p> </p> <pre><code>a = 3\nb = 5\n\nprint(a &gt; 5) # False\nprint(b &lt;= 5) # True\nprint(a + b &gt;= 5) # True\nprint(a &gt; b) # False\nprint(a + 2 == b) # True\nprint(a) # 3\nprint(b) # 5\n</code></pre> <p>Man beachte, dass <code>a</code> und <code>b</code> in diesem Code niemals ge\u00e4ndert wurden.</p> Programmausf\u00fchrung voraussagen <p>Abh\u00e4ngig von der Variablen <code>alter</code> hat die Variable <code>preis</code> einen anderen Inhalt.</p> <p>Sage zun\u00e4chst voraus, was auf der Konsole erscheint, wenn <code>alter</code> mit <code>20</code>, <code>70</code> bzw. <code>2</code> bef\u00fcllt ist.</p> <p>Wie l\u00e4sst sich also die Bestimmung des Preises allgemein beschreiben?</p> <pre><code>preis = 3.50\nalter = ...\n\nif alter &gt;= 65:\n    preis = preis - 2\n\nif alter &lt; 7:\n    preis = 0.0\n\nprint(f\"Mit {alter} Jahren zahlst du: {preis} \u20ac.\")\n</code></pre> Tipp <p>Die Zeile <code>preis = preis - 2</code> bedeutet, dass der Wert in der Variablen <code>preis</code> um <code>2</code> reduziert und dieses nun als neuer Wert in <code>preis</code> gespeichert wird.</p> L\u00f6sung L\u00f6sungsvideo <p> </p> <code>alter</code> <code>preis</code> Konsolenausgabe <code>20</code> <code>3.5</code> <code>Mit 20 Jahren zahlst du: 3.5 \u20ac</code> <code>70</code> <code>1.5</code> <code>Mit 70 Jahren zahlst du: 1.5 \u20ac</code> <code>2</code> <code>0.0</code> <code>Mit 2 Jahren zahlst du: 0 \u20ac</code> <p>Der Preis ist wie folgt aufgebaut:</p> <ul> <li>Kinder bis einschlie\u00dflich 6 Jahren zahlen nichts.</li> <li>Erwachsene ab 65 Jahren zahlen den reduzierten Preis von 1,50 \u20ac.</li> <li>Alle anderen Zahlen 3,50 \u20ac.</li> </ul> Eingabe korrigieren <p>Ersetze die <code>...</code> in folgendem Programm so, dass eine Eingabe von negativen Zahlen (z.B. <code>-100</code>) vom Programm korrigiert wird. Dazu soll zun\u00e4chst gepr\u00fcft werden, ob das eingegebene Alter negativ ist und wenn ja, soll dieses auf <code>0</code> gesetzt werden.</p> <pre><code>alter = int(input(\"Wie alt bist du?\"))\nif ...:\n    ...\n\nprint(f\"Du bist {alter} Jahre alt.\")\n</code></pre> Tipp <p>Um zu pr\u00fcfen ob eine Zahl <code>a</code> negativ ist, kann z.B. <code>a &lt; 0</code> verwendet werden.</p> L\u00f6sung L\u00f6sungsvideo <p> </p> <pre><code>alter = int(input(\"Wie alt bist du?\"))\nif alter &lt; 0:\n    alter = 0\n\nprint(f\"Du bist {alter} Jahre alt.\")\n</code></pre> Verschachtelte <code>if</code>s <p>Sag voraus, was bei Ausf\u00fchrung des Programms auf der Konsole ausgegeben wird.</p> <p>Was passiert, wenn <code>alter = 15</code> ist? </p> <p>Was passiert, wenn <code>alter = 15</code> und <code>film_genre = \"M\u00e4rchen\"</code> ist? </p> <pre><code>alter = 25\nfilm_genre = \"Horror\"\n\nif film_genre == \"Horror\":\n    print(\"Wie alt bist du denn?\")\n\n    if alter &gt;= 18:\n        print(\"Viel Spa\u00df beim Film!\")\n\n    if alter &lt; 18:\n        print(\"Das wird nichts!\")\n\nprint(\"Tsch\u00fcss!\")\n</code></pre> L\u00f6sung L\u00f6sungsvideo <p> </p> <pre><code>alter = 25\nfilm_genre = \"Horror\"\n\nif film_genre == \"Horror\":\n    print(\"Wie alt bist du denn?\")\n\n    if alter &gt;= 18:\n        print(\"Viel Spa\u00df beim Film!\")\n\n    if alter &lt; 18:\n        print(\"Das wird nichts!\")\n\nprint(\"Tsch\u00fcss!\")\n</code></pre> <p>Bei der gegebenen Variablenbelegung erscheint auf der Konsole:</p> <pre><code>Wie alt bist du denn?\nViel Spa\u00df beim Film!\nTsch\u00fcss!\n</code></pre> <p>Ist <code>alter = 15</code> und <code>alter = \"Horror\"</code> erscheint:</p> <pre><code>Wie alt bist du denn?\nDas wird nichts!\nTsch\u00fcss!\n</code></pre> <p>Ist <code>alter = 15</code> und <code>alter = \"M\u00e4rchen\"</code> erscheint:</p> <pre><code>Tsch\u00fcss!\n</code></pre>"},{"location":"content/bedingter_code/bedingungen_verkn%C3%BCpfen/","title":"Bedingungen verkn\u00fcpfen","text":"Video <p>Wir k\u00f6nnen mehrere Bedingungen auch miteinander verkn\u00fcpfen.</p> Operator Beschreibung Beispiel <code>and</code> Gibt <code>True</code> zur\u00fcck, wenn alle Parameter <code>True</code> sind. <code>x &lt; 5 and y &gt; 10</code> <code>or</code> Gibt <code>True</code> zur\u00fcck, wenn eines der Parameter <code>True</code> ist. <code>x &lt; 5 or y &gt; 10</code> <code>not</code> Invertiert die Eingabe. Aus <code>True</code> wird <code>False</code> und umgekehrt. <code>not x &gt;= 6</code> Booleans direkt als Bedingung verwenden <p>Der folgende Code beschreibt, wie im Museum die Eintrittspreise berechnet werden.</p> <p>Erkl\u00e4re in deutscher Sprache, wie sich der Preis berechnet.</p> <p>Was passiert, wenn man die Variable <code>vereinsmitglied = False</code> setzt?</p> <pre><code>alter = 65\nvereinsmitglied = True\n\npreis = 6\n\nif alter &gt; 55 or alter &lt; 5:\n    preis = preis / 2\n\nif vereinsmitglied:\n    preis = 0\n\nprint(f\"Ihr Preis ist {preis}\")\n</code></pre> L\u00f6sung L\u00f6sungsvideo <p> </p> <p>Wenn die Person \u00e4lter als 55 Jahre oder j\u00fcnger als 5 Jahre ist, wird der Preis halbiert.</p> <p>Wenn die Person Vereinsmitglied ist (also wenn die Variable vereinsmitglied auf <code>True</code> gesetzt ist), wird der Preis auf <code>0</code> gesetzt, unabh\u00e4ngig vom Alter. </p> <p>Wenn <code>vereinsmitglied</code> auf <code>False</code> gesetzt wird, hat dies zur Folge, dass die zweite Bedingung <code>if vereinsmitglied:</code> nicht erf\u00fcllt wird. Das bedeutet, dass die Person keinen kostenlosen Eintritt erh\u00e4lt.</p> Verneinungen von Aussagen <p>Im \"H Club\" werden die Eintrittspreise wie folgt berechnet:</p> <pre><code>name = \"Thure\"\nmitglied = True\n\npreis = 0\n\nif not mitglied:\n    preis = 3 \n\nif not \"h\" in name and not \"H\" in name:\n    preis = preis * 2\n\nprint(f\"{name} zahlt {preis} \u20ac.\")\n</code></pre> <ul> <li> <p>Wie viel Zahlen Emmi, Henrik und Thure (der als einziger Mitglied ist).</p> </li> <li> <p>Wie wird der Preis berechnet? </p> </li> <li> <p>Wie m\u00fcsste man den Code anpassen, wenn der Club \"H&amp;M Club\" hei\u00dfen w\u00fcrde?</p> </li> </ul> L\u00f6sung L\u00f6sungsvideo <p> </p> <ul> <li> <p>Emmi zahlt 6\u20ac, Henrik zahlt 3\u20ac und Thure zahlt 0\u20ac.</p> </li> <li> <p>Nichtmitglieder zahlen 3 \u20ac. Hat der Name kein \"h\" oder \"H\", verdoppelt sich der Preis.</p> </li> <li> <p>Erweitere die Bedingung: <code>if not \"h\" in name and not \"H\" in name and not \"m\" in name and not \"M\" in name:</code></p> </li> <li> <p>Alternativ: <code>if not (\"h\" in name or \"H\" in name or \"m\" in name or \"M\" in name):</code></p> </li> </ul> Preisberechnung basierend auf Alter und Mitgliedschaft <p>Schreibe einen kleinen Python-Code, der den Eintrittspreis berechnet. Es gelten folgende Regeln:</p> <ul> <li>Personen unter 18 Jahren zahlen 5 \u20ac.</li> <li>Personen ab 65 Jahren zahlen 5 \u20ac.</li> <li>Alle anderen zahlen 10 \u20ac.</li> <li>Mitglieder eines Clubs erhalten 50 % Rabatt auf den Eintrittspreis.</li> </ul> L\u00f6sung L\u00f6sungsvideo <p> </p> <pre><code>alter = 30\nmitglied = True\n\npreis = 10\n\nif alter &lt; 18 or alter &gt;= 65:\n    preis = 5\n\nif mitglied:\n    preis = preis / 2\n\nprint(f\"Der Preis betr\u00e4gt {preis} \u20ac.\")\n</code></pre>"},{"location":"content/collections/for_loop/","title":"for-Schleife","text":"<p>H\u00e4ufig wollen wir bestimmte Operationen auf allen Elementen einer Liste durchf\u00fchren. Dies kann zwar \u00fcber eine <code>while</code>-Schleife implementiert werden, ist aber etwas  umst\u00e4ndlich und sogar fehleranf\u00e4llig. Lieber wird mit der <code>for</code>-Schleife gearbeitet, die es erlaubt, alle Elemente einer Liste nacheinander durchzugehen, ohne dass dabei der Index zum Zugriff auf die Elemente genutzt werden muss. </p> for-loopwhile-loop <pre><code>produkte = [\"Butter\", \"Milch\", \"Wurst\"] # (1)!\n\nfor produkt in produkte: # (2)!\n    print(f\"Heute gibt es {produkt}.\") # (3)!\n</code></pre> <ol> <li>Lege eine Liste mit Elementen an, die durchlaufen werden sollen.</li> <li>Hier wird eine Variable <code>produkt</code> angelegt und diese wird nun nacheinander mit allen Elementen der Liste <code>produkte</code> bef\u00fcllt. Zuerst gilt also <code>produkt = \"Butter\"</code> und mit diesem Wert werden die n\u00e4chsten einger\u00fcckten Zeilen durgef\u00fchrt. Danach ist <code>produkt = \"Milch\"</code> und die einger\u00fcckten Zeilen werden erneut durchgef\u00fchrt. Dies geht so lange weiter, bis alle Elemente in der Liste durchlaufen wurden. </li> <li>Der einger\u00fcckte Code ist der Schleifenrumpf. Dieser wird so oft durchlaufen, wie es Elemente in der Liste gibt.</li> </ol> <p>So w\u00fcrde die Implementierung mit einer <code>while</code>-Schleife aussehen.</p> <pre><code>produkte = [\"Butter\", \"Milch\", \"Wurst\"] # (1)!\ni = 0 # (2)!\n\nwhile i &lt; len(produkte): # (3)!\n    print(f\"Heute gibt es {produkte[i]}.\") # (4)!\n    i = i + 1 # (5)!\n</code></pre> <ol> <li>Lege eine Liste mit Elementen an, die durchlaufen werden sollen.</li> <li>Es wird eine Variable <code>i</code> angelegt, die f\u00fcr den Zugriff auf die Liste \u00fcber den Index ben\u00f6tigt wird.</li> <li>Solange <code>i</code> nicht gr\u00f6\u00dfer ist als der gr\u00f6\u00dftm\u00f6gliche Index, soll die Schleife durchlaufen werden. <code>len(produkte)</code> gibt die Anzahl der Elemente in der Liste zur\u00fcck und ist hier <code>3</code>.</li> <li>Um nun auf die Elemente zuzugreifen, wird die Index-Notation <code>produkte[i]</code> verwendet.</li> <li>Abschlie\u00dfend muss der Wert f\u00fcr <code>i</code> vergr\u00f6\u00dfert werden, um sicher zu stellen, dass im n\u00e4chsten Schleifendurchlauf auch auf das n\u00e4chste Element zugegriffen wird.</li> </ol> <p>Konsolenausgabe:</p> <pre><code>Heute gibt es Butter\nHeute gibt es Milch\nHeute gibt es Wurst\n</code></pre> <p>Code im Debugger</p> <p> </p> for-Schleifen lesen <p>Gegeben sei der folgende Code. Sag voraus, was auf der Konsole erscheinen wird: <pre><code>print(\"Meine Freunde hei\u00dfen:\")\nfor name in [\"Karl\", \"Jannik\", \"Alexa\"]:\n    print(f\"{name}, \")\nprint(\"und mein bester Freund hei\u00dft Max.\")\n</code></pre></p> L\u00f6sung <pre><code>Meine Freunde hei\u00dfen:\nKarl,\nJannik,\nAlexa,\nund mein bester Freund hei\u00dft Max.\n</code></pre> Summen bilden <p>Gegeben sei der folgende Code. Sag voraus, was auf der Konsole erscheinen wird, wenn</p> <ul> <li><code>summanden = [1,2,3,4]</code></li> <li><code>summanden = [3, -3, 4, -2]</code></li> <li><code>summanden = [1]</code></li> <li><code>summanden = []</code></li> </ul> <pre><code>summanden = ...\nsumme = 0\nfor s in summanden:\n    summe = summe + s\nprint(f\"Die Summe von {summanden} ist {summe}.\")\n</code></pre> L\u00f6sung Vorraussetzung Konsolenausgabe <code>summanden = [1,2,3,4]</code> <code>Die Summe von [1,2,3,4] ist 10.</code> <code>summanden = [3, -3, 4, -2]</code> <code>Die Summe von [3, -3, 4, -2] ist 2.</code> <code>summanden = [1]</code> <code>Die Summe von [1] ist 1.</code> <code>summanden = []</code> <code>Die Summe von [] ist 0}.</code> for-Schleife schreiben <p>Schreibe mithilfe der <code>for</code>-Schleife ein Programm, das alle Elemente einer Liste miteinander multipliziert und dieses Produkt am Ende ausgibt.</p> Tipp <p>Erstelle eine Variable <code>product = 1</code>, in der du die L\u00f6sung speicherst.</p> L\u00f6sung <pre><code>factors = [2, 3, 2]\nproduct = 1\nfor f in factors:\n    product = product * f\n\nprint(f\"Das Produkt von {factors} ist {product}\") \n</code></pre> Marstransport <p>Die folgende Funktion berechnet das Marsgewicht f\u00fcr eine einzelne Variable.</p> <pre><code>gewicht = 65\nmars_faktor = 0.38\nmars_gewicht = gewicht * mars_faktor\nprint(f'Dein Marsgewicht: {mars_gewicht}')\n</code></pre> <p>a) Passe das Programm so an, dass f\u00fcr eine Liste <code>gewichte = [100, 65, 23]</code> die Berechnung durchgef\u00fchrt wird und auf der Konsole erscheint:</p> <pre><code>Dein Marsgewicht: 38.0\nDein Marsgewicht: 24.7\nDein Marsgewicht: 8.74\n</code></pre> <p>b) Erweitere das Programm, sodass zus\u00e4tzlich alle Marsgewichte in einer Liste  gespeichert und am Ende ausgegeben werden.</p> <pre><code>Dein Marsgewicht: 38.0\nDein Marsgewicht: 24.7\nDein Marsgewicht: 8.74\nMarsgewichte: [38.9, 24.7, 8.74]\n</code></pre> L\u00f6sung <p>a)</p> <pre><code>gewichte = [100, 65, 23]\nmars_faktor = 0.38\nfor gewicht in gewichte:\n    mars_gewicht = gewicht * mars_faktor\n    print(f'Dein Marsgewicht: {mars_gewicht}')\n</code></pre> <p>b)</p> <pre><code>gewichte = [100, 65, 23]\nmars_gewichte = []\nmars_faktor = 0.38\nfor gewicht in gewichte:\n    mars_gewicht = gewicht * mars_faktor\n    mars_gewichte.append(mars_gewicht)\n    print(f'Dein Marsgewicht: {mars_gewicht}')\nprint(f\"Marsgewichte: {Marsgewichte:}\")\n</code></pre> Usernamen \u00fcberpr\u00fcfen <p>In einem Onlineportal d\u00fcrfen Nutzer ihren Benutzernamen frei w\u00e4hlen, jedoch gibt es bestimmte Begriffe, die nicht als Teil des Namens auftauchen d\u00fcrfen. Diese sind in der folgenden Liste verbotener W\u00f6rter notiert:</p> <pre><code>verboten = ['admin', 'super', 'user']\n</code></pre> <p>Folgende Nutzernamen w\u00e4ren hier also verboten:</p> <ul> <li>superman</li> <li>administrator</li> <li>Radminister</li> <li>H\u00e4user</li> <li>superadmin</li> <li>admin</li> </ul> <p>Schreibe ein Programm, das den Nutzer um einen Namen bittet und eine Warnmeldung gibt, wenn der Name verboten ist.</p> Tipp <pre><code>username = input('Nutzername eingeben: ')\nverboten = ['admin', 'super', 'user']\n\nfor ...:\n    if ...:\n        print(\"Nutzername nicht erlaubt!\")\n</code></pre> L\u00f6sung <pre><code>username = input('Nutzername eingeben: ')\nverboten = ['admin', 'super', 'user']\n\nfor v in verboten:\n    if v in username:\n        print(\"Nutzername nicht erlaubt!\")\n</code></pre>"},{"location":"content/collections/lists/","title":"Listen","text":"Video <p>Derzeit k\u00f6nnen wir in einer Variablen genau einen Wert speichern.</p> <p>Wir werden nun M\u00f6glichkeiten kennenlernen, wie wir in einer Variable eine gro\u00dfe Menge von Daten speichern k\u00f6nnen.</p> <p>Die wichtigste M\u00f6glichkeit zum Speichern gro\u00dfer Datenmengen in einer Variable sind Listen.</p> <p>Eine Liste kann man sich vorstellen wie eine Variable mit mehreren durchnummerierten Schubladen. Die Nummerierung startet mit <code>0</code>, geht dann weiter zu <code>1</code>, weiter zu <code>2</code> usw.</p> <p>Wir k\u00f6nnen eine Liste definieren, indem wir die zu speichernden Elemente in eckige Klammern (<code>[...]</code>) schreiben:</p> <pre><code>trinkgeld = [70, 60, 15, 15, 0, 100, 0]\n</code></pre> <p>Um nun auf die Elemente zuzugreifen schreiben wir nach dem Variablennamen in eckigen Klammern, welchen Eintrag wir haben m\u00f6chten.</p> <pre><code>print(trinkgeld[0]) # (1)!\n</code></pre> <ol> <li>Konsolenausgabe: <code>70</code></li> </ol> <p>Code im Debugger</p> <p> </p> <p>Andererseits k\u00f6nnen wir \u00fcber die Notation Werte \u00fcberschreiben:</p> <pre><code>trinkgeld[0] = 10 # (2)!\nprint(trinkgeld[0]) # (1)!\n</code></pre> <ol> <li>Konsolenausgabe: <code>10</code></li> <li>Schreibe <code>10</code> an die erste Stelle (Index <code>0</code>) der Liste.</li> </ol> <p>Code im Debugger</p> <p> </p> <p>Variablen</p> <p> <pre><code>my_var = 5\n\nprint(my_var) # (1)!\n\nmy_var = 6 # (2)!\n</code></pre></p> <ol> <li>Zugriff direkt \u00fcber den Namen der Variablen.</li> <li>\u00dcberschreiben der Variablen. </li> </ol> <p>Listen</p> <p> <pre><code>my_list = [5, 8, 5, 1, 0,80]\n\nprint(my_list[0]) # (1)!\n\nmy_list[0] = 10 # (2)!\n</code></pre></p> <ol> <li>Zugriff auf Element \u00fcber den Index <code>0</code>.</li> <li>\u00dcberschreiben des Elements an dem Index <code>0</code>.</li> </ol> <p>Listen niemals <code>list</code> nennen!</p> <p>Der Variablenname einer Liste (oder sonst irgendeines Objektes), darf niemals <code>list</code> hei\u00dfen.</p> <p>Dies w\u00fcrde zu einer \u00dcberschreibung des <code>list</code>-Konstruktors f\u00fchren und ggf. den Rest des Pythonprogramms zerst\u00f6ren .</p> <p><code>list</code> ist hier keine Ausnahme. Hier findest du noch eine Liste aller Build-In-Functions, die man nicht als Variablennamen verwenden soll.</p> Listen lesen <p>Was erscheint hier auf der Konsole?</p> <pre><code>produkte = ['Milch', 'Butter', 'K\u00e4se']\n\nprint(produkte[2])\nprint(produkte[1])\nprint(produkte[0])\n\nprodukte[1] = 'Magarine'\n\nprint(produkte[0])\nprint(produkte[1])\nprint(produkte[1+1])\n\npos = 2\nprint(produkte[pos])\n</code></pre> L\u00f6sung L\u00f6sungsvideo <p> </p> <p>Konsolenausgabe</p> <pre><code>K\u00e4se\nButter\nMilch\nMilch\nMagarine\nK\u00e4se\nK\u00e4se\n</code></pre> Listen definieren <p>Definiere eine Liste namens <code>meine_lieblinge</code> mit deinen Lieblingsfilmen.</p> L\u00f6sung L\u00f6sungsvideo <p> </p> <pre><code>meine_lieblinge = ['Alles steht Kopf', 'Die Schlange im Schatten des Adlers', 'Der Pate']\n</code></pre> Listen mit Zahlen definieren <p>Definieren eine Liste mit den Zaheln von <code>0</code> bis <code>8</code>. Speicher diese in eine  Variable namens <code>spielfeld</code>.</p> L\u00f6sung L\u00f6sungsvideo <p> </p> <pre><code>spielfeld = [0, 1, 2, 3, 4, 5, 6, 7, 8] \n</code></pre> Listen manipulieren <p>Gegeben Sei die folgende Liste:</p> <pre><code>mitarbeiter = ['Anton', 'Bernd', 'Clara', 'Dennis']\n</code></pre> <p>Tauschen Sie <code>Bernd</code> durch einen <code>Emil</code> aus. </p> <p>Geben Sie dann jedes zweite Element der Liste aus. Die Konsolenausgabe ist also diese:</p> <pre><code>Emil\nDennis\n</code></pre> L\u00f6sung L\u00f6sungsvideo <p> </p> <pre><code>mitarbeiter = ['Anton', 'Bernd', 'Clara', 'Dennis']\n\nmitarbeiter[1] = 'Emil'\n\nprint(mitarbeiter[1])\nprint(mitarbeiter[3])\n</code></pre>"},{"location":"content/collections/lists_append/","title":"Listen erweitern","text":"Video <p>Zu einer Liste k\u00f6nnen neue Elemente mit der Methode <code>append</code> hinzugef\u00fcgt werden. Das sieht dann wie folgt aus:</p> <pre><code>fragezeichen = ['Justus'] # (1)!\nfragezeichen.append('Peter') # (2)!\nfragezeichen.append('Bob')\nprint(fragezeichen)\n</code></pre> <ol> <li>Liste wird erstellt.</li> <li>Neues Element wird mit <code>append</code> hinzugef\u00fcgt.</li> </ol> <p>Code im Debugger</p> <p> </p> Listen mit Operationen bei der Definition <p>Was erscheint hier auf der Konsole?</p> <pre><code>list_0 = []\nlist_0.append(15)\nlist_0.append(3 * 2)\nprint(list_0)\n\na = 5\nb = 15\nlist_1 = [1 + 1, 1 / 2, a, a + b]\nlist_1.append(a * b + 7)\nlist_1.append(list_1[0])\nprint(list_1)\n</code></pre> Tipp <p><code>list_0 = []</code> beschreibt eine leere Liste, also eine Liste ohne Elemente.</p> <p>Berechne zun\u00e4chst den Inhalt der Elemente in <code>list_1</code>. Die Elemente sind durch Kommas (<code>,</code>) getrennt.</p> L\u00f6sung L\u00f6sungsvideo <p> </p> <p>Konsolenausgabe</p> <pre><code>[15, 6]\n[2, 0.5, 5, 20, 15, 82, 2]\n</code></pre> Listen fortlaufend erweitern <p>Schreibe ein Programm, das den Nutzer wiederholt nach einer Zahl fragt. Das Programm hat intern eine Liste namens <code>eingaben</code>, in der alle bisher eingegebenen Zahlen gespeichert werden. Es sollen vor der Eingabe immer die bisher gespeicherten Elemente eingeblendet werden.</p> <p>Die Konsolenausgabe soll also etwa so aussehen:</p> <pre><code>Bisherige Zahlen: []\nGib eine Zahl ein: 3\nBisherige Zahlen: [3]\nGib eine Zahl ein: 10\nBisherige Zahlen: [3, 10]\nGib eine Zahl ein: -20\nBisherige Zahlen: [3, 10, -20]\nGib eine Zahl ein: \n</code></pre> Tipp Tipps ohne CodeCodevorlage mit Schleife <ul> <li>Lege dir zun\u00e4chst eine Variable <code>eingaben</code> an, in der du die Eingaben sammeln wirst. Zun\u00e4chst ist <code>eingabe</code> eine leere Liste.</li> <li>Um eine Schleife dauerhaft f\u00fcr immer zu durchlaufen kann als Bedingung <code>True</code> genutzt werden.</li> <li>Mit <code>int(input(\"Gib eine Zahl ein: \"))</code> kann man den Nutzer um eine Zahl bitten.</li> <li>F\u00fcge neue Elemente in eine Liste mit <code>append</code> ein.</li> </ul> <pre><code>eingaben = ...\nwhile ...: \n    print(f\"Bisherige Zahlen: {eingaben}\")\n    eingabe = ...\n    eingaben. ...\n</code></pre> L\u00f6sung L\u00f6sungsvideo <p> </p> <pre><code>eingaben = []\nwhile True:\n    print(f\"Bisherige Zahlen: {eingaben}\")\n    eingabe = int(input(\"Gib eine Zahl ein: \"))\n    eingaben.append(eingabe)\n</code></pre> Speicher manipulieren <p>Schreibe ein Programm, das in einer Liste die Zahlen von <code>0</code> bis <code>8</code> gespeichert hat. Ziel dieses Programms ist es nun die gespeicherten Zahlen durch Nutzereingaben zu manipulieren.</p> <p>Das Programm fragt dann den Nutzer nach einer Zahl zwischen <code>0</code> und <code>8</code>. Es speichert diese Eingabe in der Variablen namens <code>pos</code>.</p> <p>Das Programm fragt den Nutzer dann nach dem zu speichernden Text. Dieser Text wird nun in der Liste an der Postion <code>pos</code> gespeichert und der bisherige Wert wird \u00fcberschrieben.</p> <p>Erweitere das Programm so, dass der Nutzer immer wieder abgefragt wird.</p> <p>Die Konsolenausgabe sollte dann wie folgt aussehen:</p> <pre><code>Bisheriger Speicher: [0, 1, 2, 3, 4, 5, 6, 7, 8]\nAn welcher Stelle (0-8) soll gespeichert werden? 1 \nWas soll gespeichert werden? Anton\n\nBisheriger Speicher: [0, 'Anton', 2, 3, 4, 5, 6, 7, 8]\nAn welcher Stelle (0-8) soll gespeichert werden? 5 \nWas soll gespeichert werden? Britta\n\nBisheriger Speicher: [0, 'Anton', 2, 3, 4, 'Britta', 6, 7, 8]\nAn welcher Stelle (0-8) soll gespeichert werden? 1 \nWas soll gespeichert werden? Carlo\n\nBisheriger Speicher: [0, 'Carlo', 2, 3, 4, 'Britta', 6, 7, 8]\nAn welcher Stelle (0-8) soll gespeichert werden? \n</code></pre> Tipp Tipps ohne CodeCodevorlage mit Schleife <ul> <li>Lege dir zun\u00e4chst eine Variable <code>speicher</code> an mit den Zahlen von <code>0</code> bis <code>8</code> (siehe \u00dcbungsaufgabe Listen definieren mit Zahlen).</li> <li>Um eine Schleife dauerhaft f\u00fcr immer zu durchlaufen kann als Bedingung <code>True</code> genutzt werden.</li> <li>Nutzerabfragen k\u00f6nnen mit der <code>input</code> Funktion eingeholt werden.</li> <li>Nutzereingaben liefern immer nur Strings zur\u00fcck. Wenn sie als Integer gebraucht werden, nutze <code>int(input(...))</code>.</li> <li>Die Postion, die manipuliert werden muss, steht in <code>pos</code>.</li> </ul> <pre><code>speicher = ...\nwhile ...:\n    print(f\"Bisheriger Speicher: { speicher }\")\n    pos = ...\n    eingabe = ...\n    speicher[...] = ...\n    print()\n</code></pre> L\u00f6sung L\u00f6sungsvideo <p> </p> <pre><code>speicher = [0, 1, 2, 3, 4, 5, 6, 7, 8]\nwhile True:\n    print(f\"Bisheriger Speicher: { speicher }\")\n    pos = int(input('An welcher Stelle (0-8) soll gespeichert werden? '))\n    eingabe = input('Was soll gespeichert werden? ')\n    speicher[pos] = eingabe\n    print()\n</code></pre>"},{"location":"content/collections/weitere_datenstrukturen/","title":"Set","text":"Video <p>Sets (deutsch: Mengen ) sind listen sehr \u00e4hnlich, sie haben aber zwei f\u00fcr uns wichtige Unterschiede:</p> <ul> <li>Jedes Element in der Liste darf nur einmal auftauchen.</li> <li>Mengen haben keine Ordnung, das hei\u00dft, wir k\u00f6nnen nicht auf das <code>x</code>-te Element zugreifen.</li> <li>Sets werden mit geschweifen Klammern definiert, statt mit eckigen.</li> </ul> <p>Ein Anwendungsfall f\u00fcr Sets ist das Finden einmaliger Elemente in Listen.</p> <pre><code>my_list = [1, 1, 2, 1, 2, 3] # (1)!\nmy_set = set(my_list) # (2)!\nprint(my_set) # (3)!\n</code></pre> <ol> <li>Liste <code>my_list</code> wird erstellt. Manche Elemente sind mehrfach vorhanden.</li> <li>Aus der Liste wird ein Set (Menge) gemacht.</li> <li>In der Liste sind nun alle Elemente einmalig.</li> </ol> <p>Code im Debugger</p> <p> </p>"},{"location":"content/collections/weitere_datenstrukturen/#tupel","title":"Tupel","text":"Video <p>Tupel sind fast identisch zu listen. Hier sind die f\u00fcr uns entscheidenden Unterschiede:</p> <ul> <li>Tupel werden mit runden <code>()</code> statt mit eckigen Klammern <code>[]</code> definiert.</li> <li>Tupel lassen sich im Nachhinein nicht mehr \u00e4ndern.</li> </ul> <pre><code>my_tuple = (1, 2, 3) # (1)!\nprint(f\"Erstes Element: {my_tuple[0]}\") # (2)!\n\nmy_tuple[0] = 4 # (3)! \n</code></pre> <ol> <li>Ein Tupel wird hier definiert.</li> <li>Der Zugriff auf die Elemente des Tupels sieht genau so aus wie bei Listen.</li> <li>Hier kommt es bei der Ausf\u00fchrung zu einem Fehler, denn der Inhalt eines Tupels kann im Nachhinein nicht mehr ge\u00e4ndert werden. Auch Methoden wie <code>append</code> existieren nicht bei Tupeln.</li> </ol>"},{"location":"content/collections/weitere_datenstrukturen/#dictionary","title":"Dictionary","text":"Video <p>Dictionaries sind eine h\u00e4ufig verwendete Datenstruktur, die man als eine Liste mit speziellen Zugriffsm\u00f6glichkeiten betrachten kann. Bei einer Liste greift man auf die Werte immer \u00fcber Zahlen zu. Bei einem Dictionary wird auf die Werte (Values) \u00fcber  vorher definierte Schl\u00fcssel (Keys) zugegriffen.</p> <p>Wir k\u00f6nnen uns also vorstellen, dass die Schubladen in unseren Schr\u00e4nken nicht durchnummeriert sind, sondern eine Aufschrift haben.</p> <p>Listen</p> <p> <pre><code>my_list = [5, 8, 5, 1, 0,80]\n\nprint(my_list[0]) # (1)!\n\nmy_list[0] = 10 # (2)!\n</code></pre></p> <ol> <li>Zugriff auf Element \u00fcber den Index <code>0</code>.</li> <li>\u00dcberschreiben des Elements an dem Index <code>0</code>.</li> </ol> <p>Dictionaries</p> <p> <pre><code>my_dict = {\n    'Hunde': 5,\n    'Katzen': 8,\n    'H\u00fchner': 5,\n    'H\u00e4hne': 1,\n    'Schweine': 0,\n    'K\u00fche': 80\n}\n\nprint(my_dict['Hunde']) # (1)!\n\nmy_dict['Hunde'] = 6 # (2)!\n</code></pre></p> <ol> <li>\u00dcber den Schl\u00fcssel <code>Hunde</code> wird auf das Value <code>5</code> zugegriffen.</li> <li>Ein neuer Value <code>6</code> wird beim Schl\u00fcssel <code>Hunde</code> gespeichert. </li> </ol>"},{"location":"content/functions/functions/","title":"Funktionen definieren","text":"Video <p>Bisher sind alle unsere Codebeispiele so geschrieben, dass der jeweilige Code einmalig ausgef\u00fchrt und dann nicht mehr gebraucht wird. Das ist normalerweise nicht der Fall. Normalerweise werden Codeabschnitte immer wieder und in verschiedenen Kontexten aufgerufen. Zum Beispiel wollen wir Code bereitstellen, um den BMI einer Person zu berechnen. Den Code m\u00f6chte man einerseits f\u00fcr beliebige Personen ausf\u00fchren und andererseits an verschiedenen Stellen (z.B. bei verschiedenen Anzeigen in einer App).</p> <p>Die wichtigste M\u00f6glichkeit zur Strukturierung des Codes sind Funktionen bzw. Methoden.</p> <p>In Python ist eine Funktion eine selbstst\u00e4ndige, wiederverwendbare Codeeinheit, die dazu dient, eine bestimmte Aufgabe zu erledigen. Funktionen k\u00f6nnen Parameter akzeptieren,  Operationen durchf\u00fchren und R\u00fcckgabewert liefern.</p> <p>Beliebte Metaphern, um Funktionen vorzustellen sind:</p> <ul> <li>Eine Funktion ist eine Maschine, in die wir Rohstoffe stopfen, damit sie diese verarbeitet und uns ein Produkt liefert.</li> <li>Eine Funktion ist wie ein Rezept. Es erwartet bestimmte Zutaten und wenn wir der Anleitung folgen, erhalten wir eine raffinierte Mahlzeit.</li> </ul> <pre><code>graph TD;\n    A([Parameter]) --&gt; B[Funktion] --&gt; C([R\u00fcckgabewert])\n    A1([Zutaten]) --&gt; B1[Rezept] --&gt; C1([Mahlzeit])\n    A2([Rohstoffe]) --&gt; B2[Maschine] --&gt; C2([Produkt])</code></pre> Ein alter Schuh <p>Wir haben bereits an vielen Stellen Funktionen genutzt, die in Python eingebaut sind. Welche sind das?</p> Tipp <ul> <li>Wie wurden Inhalte auf der Konsole ausgegeben?</li> <li>Wie konnten Nutzereingaben vorgenommen werden?</li> </ul> L\u00f6sung <p>Wir haben bereits die in Python eingebauten Funktionen <code>print()</code> und <code>input()</code> genutzt. Auch <code>int()</code> und <code>float()</code> sind Funktionen.</p> <p>Im folgenden Code wird unsere erste eigene Funktion <code>hoch()</code> definiert und diese dann drei mal aufgerufen:</p> <pre><code>def hoch(): # (1)!\n    print(\"Er lebe...\") # (2)!\n    print(\"HOCH!\")\n\nhoch() # (3)!\nhoch() # (4)!\nhoch() # (5)!\n</code></pre> <ol> <li>Die Funktion wird mit dem Schl\u00fcsselwort <code>def</code> definiert. Wir geben ihr den Namen <code>hoch</code>. Da sie keine Parameter hat, schreiben wir hier einfach runde Klammern <code>()</code> und danach einen <code>:</code> (so wie beim <code>if</code>).Diese Erste Zeile einer Funktion wird Funktionskopf genannt.</li> <li>Die nun einger\u00fcckten Zeilen sind der Funktionsrumpf oder Funktionsk\u00f6rper. Diese werden nur durchgef\u00fchrt, wenn die Funktion aufgerufen wird.</li> <li>Wir f\u00fchren in dieser Zeile die Funktion aus. Dazu schreiben wir den Funktionsnamen auf, gefolgt von runden Klammern.</li> <li>Wir f\u00fchren die Funktion erneut aus...</li> <li>Und noch ein drittes Mal\ud83e\udd73</li> </ol> <p>Code im Debugger</p> <p> </p> Seid gegr\u00fc\u00dft! <p>Gegeben sei der folgende Code. Beschreibe, was auf der Konsole erscheint, wenn dieser durchgef\u00fchrt wird:</p> <pre><code>def gru\u00df_nord():\n    print('Moin')\n\ndef gru\u00df_s\u00fcd():\n    print('Gr\u00fc\u00df Gott')\n\ngru\u00df_nord()\ngru\u00df_s\u00fcd()\ngru\u00df_s\u00fcd()\ngru\u00df_nord()\n</code></pre> <p>Wie m\u00fcsste man den Code anpassen, damit alle norddeutschen Gr\u00fc\u00dfe <code>Moin moin!</code> sind? </p> L\u00f6sung L\u00f6sungsvideo <p> </p> <p>Auf der Konsole erscheint: <pre><code>Moin\nGr\u00fc\u00df Gott\nGr\u00fc\u00df Gott\nMoin\n</code></pre></p> <p>Zeile 2 muss wie folgt ge\u00e4ndert werden, um den gew\u00fcnschten Gru\u00df zu erhalten:</p> <pre><code>def gru\u00df_nord():\n    print('Moin moin!')\n</code></pre> Eigene Funktion schreiben <p>Erstelle eine Funktion <code>countdown</code>, die auf der Konsole die Zahlen von <code>10</code> bis <code>0</code> ausgibt.</p> <p>Bonus \ud83d\ude80 Verwende eine <code>while</code>-Schleife in deiner Implementierung.</p> L\u00f6sung L\u00f6sungsvideo <p> </p> <pre><code>def countdown():\n    print(10)\n    print(9)\n    print(8)\n    print(7)\n    print(6)\n    print(5)\n    print(4)\n    print(3)\n    print(2)\n    print(1)\n    print(0)\n\ncountdown()\n</code></pre> <p>L\u00f6sung mit <code>while</code>:</p> <pre><code>def countdown():\n    counter = 10\n    while counter &gt; -1:\n        print(counter)\n        counter = counter - 1\n\ncountdown()\n</code></pre>"},{"location":"content/functions/functions_with_parameters/","title":"Funktionen mit Parametern","text":"Video <p>\u00dcber Parameter k\u00f6nnen wir daf\u00fcr sorgen, dass Funktionen nicht immer exakt das Gleiche tun, sondern, eben abh\u00e4ngig von  den \u00fcbergebenen Parametern, in ihren Ergebnissen variieren, obwohl die Rechenvorschriften gleich sind.</p> <p>Im Bild gesprochen: Ein Rezept besteht einerseits aus einer Liste von Zubereitungsschritten (Funktionsk\u00f6rper) aber auch aus einer Auflistung der Zutaten (Parameter). Nun kann man zwei verschiedene Kuchen mit demselben Rezept  backen, indem man die Zutaten variiert. So macht es z.B. einen Unterschied, welche konkrete Apfelsorte man in einem Apfelkuchen verwendet.</p> <p>Definieren wir Parameter in einer Funktion, so m\u00fcssen wir diese beim Funktionsaufruf mit Klammern angeben:</p> <pre><code>def print_greeting(name, age): # (1)!\n    print(f\"Hallo {name}!\") # (2)!\n    if age &gt; 65: # (3)!\n        print(f\"Geht es?\") # (4)! \n\nprint_greeting(\"J\u00f6rg\", 68) # (5)!\nprint_greeting(\"Kevin\", 20) # (6)!\n</code></pre> <ol> <li>Bei der Funktionsdefinition werden alle Parameter mit <code>,</code> getrennt in die runden Klammern geschrieben.</li> <li>Der erste \u00fcbergebene Parameter wird hier in der Konsolenausgabe verwendet.</li> <li>Der zweite \u00fcbergebene Parameter wird hier in der Bedingung benutzt.</li> <li>Auch diese zwei Mal einger\u00fcckte Zeile geh\u00f6rt noch zum Funktionsrumpf.</li> <li>Die Funktion wird hier aufgerufen. Die Argumente sind <code>J\u00f6rg</code> und <code>68</code>, welche f\u00fcr die Paramter <code>name</code> und <code>age</code> eingesetzt werden.</li> <li>Die Funktion wird hier erneut aufgerufen, aber mit anderen Argumenten. Dies f\u00fchrt zu anderen Konsolenausgaben als bei der ersten Durchf\u00fchrung. </li> </ol> <pre><code>graph TD;\n    P1([\"age\"]) --&gt; F[print_greeting]\n    P2([\"name\"]) --&gt; F</code></pre> <p>Code im Debugger</p> <p> </p> Eigene Funktion mit Parameter schreiben <p>Erstelle eine Funktion <code>countdown_from(n)</code>, die auf der Konsole die Zahlen von <code>n</code> bis <code>0</code> ausgibt.</p> L\u00f6sung L\u00f6sungsvideo <p> </p> <pre><code>def countdown_from(n):\n    counter = n\n    while counter &gt;= 0:\n        print(counter)\n        counter = counter - 1\n\ncountdown_from(7)\n</code></pre>"},{"location":"content/functions/functions_with_returns/","title":"R\u00fcckgabewerte","text":"Video <p>Nun ist noch wichtig zu erw\u00e4hnen, dass Funktionen nicht nur verarbeiten, sondern auch ein Ergebnis am Ende ihrer Durchf\u00fchrung zur\u00fcckgeben k\u00f6nnen. Der Wert, der zur\u00fcckgegeben werden soll, steht in einer Zeile mit einem vorangehenden <code>return</code>.</p> <pre><code>def quadrat(zahl): # (1)!\n    return zahl * zahl # (2)!\n\nx = 4 # (3)!\nq = quadrat(x) # (4)!\n\nprint(f\"{x}\u00b2 = {q}\") # (5)!\n</code></pre> <ol> <li>Beim Funktionskopf sagen wir, dass es einen Paramter gibt. Dass es eine R\u00fcckgabe geben wird, l\u00e4sst sich hier nicht erkennen.</li> <li>Der Parameter <code>zahl</code> wird mit sich selbst multipliziert und das Ergebnis dann zur\u00fcckgegeben, da ein <code>return</code> am Anfang der einger\u00fcckten Zeile steht. </li> <li>Wir speichern in der Variablen <code>x</code> das Argument.</li> <li>Wir \u00fcbergeben <code>x</code> an die Funktion und speichern die R\u00fcckgabe in der Variablen <code>q</code>.</li> <li>Wir geben die Ergebnisse fein s\u00e4uberlich auf der Konsole aus.</li> </ol> <pre><code>graph TD;\n    P1([zahl]) --&gt; F[quadrat] --&gt; R([Ergebnis])</code></pre> <p>Code im Debugger</p> <p> </p> Eigene Funktion mit R\u00fcckgabe schreiben <p>Schreibe eine Funktion <code>alle_gleich(a, b, c)</code>, die drei Parameter annimmt und <code>True</code> zur\u00fcckgibt, wenn alle gleich sind und <code>False</code>, wenn nicht.</p> <pre><code>print(alle_gleich(1, 1, 1)) # True\nprint(alle_gleich(3, 1 + 1 + 1, 5 - 2)) # True\nprint(alle_gleich(1, 1, 2)) # False\nprint(alle_gleich(3, 2, 1)) # False\n</code></pre> Tipp <p>Mit <code>a == b</code> k\u00f6nnen wir pr\u00fcfen, ob zwei Elemente gleich sind.</p> L\u00f6sung L\u00f6sungsvideo <p> </p> <pre><code>def alle_gleich(a, b, c):\n    return a == b == c\n\nprint(alle_gleich(1, 1, 1)) # True\nprint(alle_gleich(3, 1 + 1 + 1, 5 - 2)) # True\nprint(alle_gleich(1, 1, 2)) # False\nprint(alle_gleich(3, 2, 1)) # False\n</code></pre> Komplexe Funktion lesen <p>Das folgende Programm berechnet einen Preis.</p> <p>Was erscheint hier auf der Konsole, wenn das Programm ausgef\u00fchrt wird?</p> <p>Erkl\u00e4re, wie sich der Preis berechnet.</p> <pre><code>def berechne_rabbatierten_preis(preis, wochentag, alter):\n    rabatt = 0\n\n    if wochentag == \"Sonntag\" or wochentag == \"Samstag\":\n        rabatt = rabatt + 0.25\n\n    if alter &gt; 65 or alter &lt; 6:\n        rabatt = rabatt + 0.5\n\n    return preis * (1 - rabatt)\n\n\nbasis_preis = 10\nheute = \"Montag\"\nalter_kunde = 70\n\nend_preis = berechne_rabbatierten_preis(basis_preis, heute, alter_kunde)\nprint(end_preis)\n</code></pre> L\u00f6sung L\u00f6sungsvideo <p> </p> <p>Am Wochenende gibt es einen Rabatt von 25% und f\u00fcr Kinder bis einschlie\u00dflich f\u00fcnf Jahren und Erwachsene ab 66 Jahren einen zus\u00e4tzlichen Rabatt von 50%.</p> <p>Konsolenausgabe:</p> <pre><code>5.0\n</code></pre>"},{"location":"content/installation/installation/","title":"Installation","text":"Video <p>Um mit dem Programmieren loslegen zu k\u00f6nnen m\u00fcssen wir zun\u00e4chst Python und eine Entwicklungsumgebung installieren:</p> <ul> <li> <p> Python</p> <p>Um Pythonprogramme schreiben und ausf\u00fchren zu k\u00f6nnen, ben\u00f6tigst du das Programm Python auf dem Rechner. Dann k\u00f6nnen wir .py-Dateien schreiben und ausf\u00fchren.</p> <p>Installiere Python \u00fcber Microsoft Store (1) oder python.org</p> <ol> <li>Suche nach \"Store\" in der Suchleiste, um den Microsoft Store auf deinem Rechner zu finden. Hier kannst du nach \"Python 3.12\" suchen und es installieren.</li> </ol> </li> <li> <p>Entwicklungsumgebung</p> <p>Um bequem Pythonprogramme zu schreiben, nutzen wir eine Entwicklungsumgebung. (1)</p> <ol> <li>Alle hier vorgeschlagenen Entwicklungsumgebungen sind gleichwertig. Wir werden hier mit Visual Studio Code arbeiten.</li> </ol>  Visual Studio Code PyCharm Community Edition <p>Microsoft Store (1) oder code.visualstudio.com</p> <ol> <li>Suche nach \"Store\" in der Suchleiste, um den Microsoft Store auf deinem Rechner zu finden. Hier kannst du nach \"vscode\" suchen und es installieren.</li> </ol> <p>Starte Visual Studio Code und installiere dann die Erweiterung \"Python\". (1)</p> <ol> <li></li> </ol> <p>jetbrains.com (1)</p> <ol> <li>Nutze den unteren Link zum Download der kostenfreien Community Edition (schwarz hinterlegt). Der obere Link ist eine 30-Tage-Testversion der Professional Edition.</li> </ol> </li> </ul> Dein erstes Programm Video <p> </p> <ul> <li>Erstelle einen leeren Ordner \"python-schulung\".</li> <li>Starte Visual Studio Code.</li> <li>Gehe auf \"File\" &gt; \"Open Folder\" und w\u00e4hle den von dir erstellten Ordner aus. (1)</li> <li>Best\u00e4tige, dass du dem Projekt vertraust. (5)</li> <li>Erstelle eine neue Python-Datei namens \"hallo.py\", indem du auf das  neben dem Ordnernamen klickst. (2)</li> <li>Schreibe <code>print(\"Hallo Welt\")</code> in die Datei.</li> <li>Aktiviere das automtische Speichern, indem du auf \"File\" &gt; \"Auto Save\" klickst. (3)</li> <li>Klicke auf die -Taste oben rechts, um die Datei auszuf\u00fchren. (4)</li> <li>Ein Terminal \u00f6ffnet sich unten und auf dieser erscheint die Ausgabe <code>Hallo Welt</code>. \ud83c\udf89\ud83c\udf89\ud83c\udf89 </li> </ul> <p> </p> <ol> <li></li> <li>Das Symbol taucht erst auf, wenn man mit der Maus dar\u00fcber ist.\ud83d\ude44</li> <li></li> <li></li> <li></li> </ol> <p>Strukturiert bleiben</p> <p>Im Folgenden werden Sie viele .py-Dateien erstellen. Sortieren sie diese mit Hilfe von Unterordnern, um nicht die \u00dcbersicht zu verlieren. So k\u00f6nnen Sie z.B. f\u00fcr jede Seite hier im Browser einen eigenen Unterordner mit dem Namen des jeweiligen Abschnitts erstellen.</p>"},{"location":"content/ki/umgang/","title":"Umgang mit Sprachmodellen","text":"<p>Mit der Ver\u00f6ffentlichung des Large Language Models ChatGPT ist eine neue \u00c4ra des Programmierens und Programmieren Lernens angebrochen.</p> <p>Textgenerierende Sprachmodelle k\u00f6nnen eine riesige Hilfe im Arbeitsalltag darstellen, sowohl f\u00fcr Anf\u00e4nger als auch f\u00fcr  fortgeschrittene Entwickler.</p> <p>Man sollte jedoch wissen, wo die St\u00e4rken der Modelle wirklich liegen und welche Gefahren sie bergen.</p>"},{"location":"content/ki/umgang/#gefahren","title":"Gefahren","text":"<ul> <li>Teile den Modellen keine sensiblen Daten mit. Denn diese gehen in das Modell ein und k\u00f6nnten von der KI-Firma genutzt oder durch geschickte Fragen von anderen Nutzern dem Modell wieder entlockt werden.</li> <li>Sprachmodelle l\u00fcgen oft, wenn sie keine Antwort wissen.</li> <li>Sprachmodelle lassen sich leicht dazu zu \u00fcberreden zu l\u00fcgen, nur um dem Nutzer zuzustimmen.</li> <li>Sprachmodelle machen Fehler.</li> <li>Sprachmodelle werden schlechter. Das kann man teilweise schon in einem einzigen l\u00e4ngeren Gespr\u00e4ch beobachten. Aufgaben, die es zu Beginn noch perfekt durchf\u00fchren konnte, k\u00f6nnen sp\u00e4ter Fehler aufweisen.</li> </ul>"},{"location":"content/ki/umgang/#gute-anwendungsfalle","title":"Gute Anwendungsf\u00e4lle","text":"<ul> <li>Funktionen und Bibliotheken finden, die einem das Leben vereinfachen.</li> <li>Fehler im Code finden.</li> <li>Fehlermeldungen verstehen.</li> </ul>"},{"location":"content/ki/umgang/#tipps-bei-der-nutzung","title":"Tipps bei der Nutzung","text":"<ul> <li>Beschreibe deine Anforderungen genau.</li> <li>Fange mit einer einfachen Variante deines Problems an.</li> <li>Tausche regelm\u00e4\u00dfig die \"Mach das f\u00fcr mich\"-Mentalit\u00e4t gegen eine \"Ich will mit Beispielen verstehen\"-Mentalit\u00e4t aus.</li> <li>Unterst\u00fctze, indem du selbst nach Fehlerquellen suchst.</li> <li>Frag gerne nach, ob es noch andere oder bessere L\u00f6sungswege gibt. Oft findet das Modell welche.</li> </ul> Lasst uns forschen <p>Lade die folgende Datei mit Verkaufszahlen herunter (das Passwort erh\u00e4lst du vom Trainer).</p> <p>Wir wollen nun ein Sprachmodell nutzen, um mit ihm diesen Datensatz zu erforschen.</p> <p>Dokumente herunterladen</p>"},{"location":"content/loops/loops/","title":"Codewiederholung","text":"<p># Codewiederholung</p> Video <p> </p> <p>Mit den <code>if</code>-Bl\u00f6cken haben wir kennengelernt, wie man einen Codeblock nur unter bestimmten Bedingungen durchf\u00fchrt.</p> <p>Wir wollen nun die <code>while</code>-Bl\u00f6cke anschauen. Diese sind so \u00e4hnlich wie <code>if</code>-Bl\u00f6cke, denn auch sie pr\u00fcfen eine Bedingung und f\u00fchren den einger\u00fcckten Code nur aus, wenn die Bedinung <code>True</code> ist. ABER: Bei <code>while</code> wird nach jeder Durchf\u00fchrung des einger\u00fcckten Codes gepr\u00fcft, ob die Bedingung immer noch erf\u00fcllt ist! Und wenn ja, dann wird der einger\u00fcckte Codeblock NOCH MAL durchgef\u00fchrt. Und das immer wieder!</p> <pre><code>zahl = 1 # (1)!\nwhile zahl &lt; 100:  # (2)!\n    print(zahl)  # (3)!\n    zahl = zahl * 2  # (4)!\nprint(f'Finaler Wert: {zahl}.') # (5)!\n</code></pre> <ol> <li>Die Variable <code>zahl</code> wird mit dem Wert <code>1</code> angelegt.</li> <li>Es wird gepr\u00fcft, ob der Wert in <code>zahl</code> kleiner als <code>100</code> ist. Wenn ja, werden die n\u00e4chsten beiden Zeilen ausgef\u00fchrt. Wenn nein, so wird direkt zu Zeile 5 gesprungen.</li> <li>Auf der Konsole wird der aktuelle Wert von <code>zahl</code> ausgegeben.</li> <li>Der Wert von <code>zahl</code> wird verdoppelt und dies in <code>zahl</code> gespeichert.    Achtung: Danach geht es in Zeile 2 weiter!</li> <li>Abschlie\u00dfend wird der finale Wert von <code>zahl</code> ausgegeben.</li> </ol> <pre><code>stateDiagram-v2\n    classDef yourState font-style:italic,font-weight:bold,fill:white\n\n    B:Bedingung \u00fcberpr\u00fcfen\n    I:Code *im* einger\u00fcckten&lt;br/&gt;Block ausf\u00fchren\n    F:Code *nach* einger\u00fccktem&lt;br/&gt;Block ausf\u00fchren\n    [*] --&gt; B:::yourState\n    B --&gt; I : True\n    I --&gt; B : Springe zur\u00fcck\n    B --&gt; F : False</code></pre> <p>Code im Debugger</p> <p> </p> <p>Endlosschleifen abbrechen</p> <p>Solltest Du in eine Endlosschleife geraten, kannst Du ins Terminal klicken und die Ausf\u00fchrung mit Ctrl + C abbrechen.</p> Schleifen lesen <p>Schau dir den folgenden Code an und vollziehe nach, was passiert, wenn dieser ausgef\u00fchrt wird.</p> <p>Wie oft wird der Rumpf der <code>while</code>-Schleife durchlaufen?</p> <p>Wie oft wird die Bedingung gepr\u00fcft?</p> <p>Was erscheint auf der Konsole?</p> <p>Welchen Wert hat <code>a</code> am Ende des Programms?</p> <pre><code>a = 10\nwhile a &gt; 0:\n    print(a)\n    a = a - 3\n</code></pre> <p>Beantworte alle Fragen noch mal, aber nun sind die Zeilen 3 und 4 vertauscht!</p> <pre><code>a = 10\nwhile a &gt; 0:\n    a = a - 3\n    print(a)\n</code></pre> L\u00f6sung L\u00f6sungsvideo <p> </p> <p>Die Schleiferumpf wird insgesamt drei Mal durchlaufen.</p> <p>Die Bedingung wird vier Mal gepr\u00fcft.</p> <p>Auf der Konsole erscheint</p> <pre><code>10\n7\n4\n1\n</code></pre> <p><code>a</code> hat am Ende des Programms den Wert <code>-2</code></p> <p>Wenn man die Zeilen 3 und 4 vertauscht \u00e4ndert sich nur die Konsolenausgabe. Alles andere bleibt gleich.</p> <pre><code>7\n4\n1\n-2\n</code></pre> Variable Durchlaufzahl <p>Ersetze die <code>...</code> mit den verschiedenen Operatoren <code>+</code>, <code>-</code>, <code>*</code> und <code>/</code>.</p> <p>Was kannst du beobachten? Wie oft wird die Schleife den Rumpf durchlaufen?</p> <p>Ersetze in der letzten Zeile die <code>...</code>, sodass auf der Konsole ausgegeben wird <code>Die Schleife wurde x-Mal durchlaufen</code>,  wobei <code>x</code> durch die richtige Zahl ersetzt wird.</p> <pre><code>z = 10\ncounter = 0\nwhile z &gt; 0 and z &lt; 20:\n    print(z)\n    z = z ... 2\n    counter = counter + 1\n\nprint(...)\n</code></pre> Tipp <p>Was tut die Variable <code>counter</code>?</p> <p>Manche Schleifen enden nie...</p> L\u00f6sung L\u00f6sungsvideo <p> </p> <p>Die Variable <code>counter</code> z\u00e4hlt mit, wie oft der Schleifenrumpf durchlaufen wurde.</p> <p>Die letzte Zeile lautet:</p> <pre><code>print(f\"Die Schleife wurde {counter}-Mal durchlaufen\"\n</code></pre> <code>+</code>:<code>-</code>:<code>*</code>:<code>/</code>: <pre><code>10\n12\n14\n16\n18\nDie Schleife wurde 5-Mal durchlaufen.\n</code></pre> <pre><code>10\n8\n6\n4\n2\nDie Schleife wurde 5-Mal durchlaufen.\n</code></pre> <pre><code>10\nDie Schleife wurde 1-Mal durchlaufen.\n</code></pre> <pre><code>10\n5.0\n2.5\n1.25\n0.625\n0.3125\n0.15625\n0.078125\n0.0390625\n0.01953125\n0.009765625\n0.0048828125\n0.00244140625\n0.001220703125\n0.0006103515625\n0.00030517578125\n0.000152587890625\n...\n5e-323\n2.5e-323\n1e-323\n5e-324\nDie Schleife wurde 1078-mal durchlaufen.\n</code></pre> <p>Die Schleife bricht ab, als die kleinste <code>float</code>-Zahle durch <code>2</code> geteilt und <code>0</code> errechnet wurde (was mathematisch nicht korrekt ist). K\u00f6nnte Python Kommazahlen mathematisch korrekt berechnen w\u00fcrden wir hier in eine Endlosschleife geraten.</p> Summe von Eingaben bilden <p>Schreibe ein Programm, das den Nutzer nach einer Zahl fragt. Das Programm kann intern in einer Variablen namens <code>summe</code> die Summe  aller bisher abgefragten Zahlen bilden und ausgeben.</p> <p>Die Konsolenausgabe soll also in etwa so aussehen:</p> <pre><code>Bisherige Summe: 0\nGib eine Zahl ein: 3\nBisherige Summe: 3\nGib eine Zahl ein: 10\nBisherige Summe: 13\nGib eine Zahl ein: -20\nBisherige Summe: -7\nGib eine Zahl ein: \n</code></pre> Tipp Tipps ohne CodeCodevorlage mit Schleife <ul> <li>Lege dir zun\u00e4chst eine Variable <code>summe</code> an, in der du die Summanden zusammenz\u00e4hlen wirst. Was ist ein sinnvoller Startwert?</li> <li>Um eine Schleife dauerhaft f\u00fcr immer zu durchlaufen kann als Bedingung <code>True</code> genutzt werden.</li> <li>Mit <code>int(input(\"Gib eine Zahl ein: \"))</code> kann man den Nutzer um eine Zahl bitten.</li> <li>Addiere die Eingabe zu <code>summe</code> und speichere diese. </li> </ul> <pre><code>summe = ...\nwhile ...: \n    print(f\"Bisherige Summe: {summe}\")\n    eingabe = ...\n    summe = ...\n</code></pre> L\u00f6sung L\u00f6sungsvideo <p> </p> <pre><code>summe = 0\nwhile True:\n    print(f\"Bisherige Summe: {summe}\")\n    eingabe = int(input(\"Gib eine Zahl ein: \"))\n    summe = summe + eingabe\n</code></pre> Bl\u00f6cke in Bl\u00f6cken <p>Gegeben Sei der folgende Code:</p> <pre><code>kunden = 0\nwhile not kunden == 19:\n    print(kunden)\n    kunden = kunden + 5\n\n    if kunden &gt;= 12:\n        kunden = kunden - 7\n</code></pre> <p>Erkl\u00e4re in Deinen Worten, was hier passiert und schreibe die Konsolenausgabe auf.</p> L\u00f6sung L\u00f6sungsvideo <p> </p> <ul> <li>In jedem Schleifendurchlauf soll <code>kunden</code> um <code>5</code> wachsen.</li> <li>Wenn <code>kunden</code> dann gr\u00f6\u00dfer als <code>12</code> ist, sollen <code>7</code> abgezogen werden.</li> <li>Wenn <code>kunden</code>gleich <code>19</code> ist, soll die Schleife enden.</li> </ul> <p>Konsolenausgabe</p> <pre><code>0\n5\n10\n8\n6\n11\n9\n7\n5\n...\n</code></pre> <p>Da es ab der <code>5</code> wieder von vorne losgeht, gilt niemals <code>kunden == 19</code> und somit bricht die Schleife niemals ab.</p> Spielerwechsel <p>Gegeben Sei der folgende Code:</p> <pre><code>jetziger_spieler = \"Hans\"\nn\u00e4chster_spieler = \"Clara\"\n\nwhile True:\n\n    ...\n\n    print(jetziger_spieler)\n</code></pre> <p>Ziel ist es den Code so zu erweitern, dass immer abwechselnd die Namen der beiden Spieler ausgegeben werden.</p> <p>Erwartete Ausgabe</p> <pre><code>Clara\nHans\nClara\nHans\nClara\nHans\n...\n</code></pre> Tipp <p>Errinnere dich, wie man zwei Variablen miteinander vertauscht. Dazu gab es eine \u00dcbungsaufgabe namens Variableninhalte tauschen.</p> L\u00f6sung L\u00f6sungsvideo <p> </p> <pre><code>jetziger_spieler = \"Hans\"\nn\u00e4chster_spieler = \"Clara\"\n\nwhile True:\n\n    zwischenspeicher = jetziger_spieler\n    jetziger_spieler = n\u00e4chster_spieler\n    n\u00e4chster_spieler = zwischenspeicher\n\n    print(jetziger_spieler)\n</code></pre>"},{"location":"content/project/tic_tac_toe/","title":"Projekt: Tic Tac Toe","text":"Video <p>In diesem Abschnitt werden wir unser bisheriges K\u00f6nnen in einem kleinen Projekt zusammenstellen. Wir wollen das Spiel <code>TicTacToe</code> implementieren.</p> <p>(Vereinfachte) Spielregeln:</p> <ul> <li>Es wird ein quadratisches Spielfeld aus 3x3 (also 9) Feldern gezeichnet.</li> <li>Der Erste Spieler tr\u00e4gt ein <code>x</code> in eines der Felder ein.</li> <li>Danach tr\u00e4gt der zweite Spiler ein <code>o</code> in eines der Felder ein.</li> <li>Dies wird abwechselnd so lange durchgef\u00fchrt, bis in einer Zeile, Spalte oder Diagonalen dreimal das gleiche Symbol auftaucht. Der Spieler, der dieses Symbol zeichnet, gewinnt.</li> </ul> <p>Das Ganze soll nachher so aussehen:</p> <pre><code> 0 | 1 | 2 \n 3 | 4 | 5\n 6 | 7 | 8\nSpieler x, wo willst du setzen? 0\n x | 1 | 2 \n 3 | 4 | 5\n 6 | 7 | 8\nSpieler o, wo willst du setzen? 1\n x | o | 2 \n 3 | 4 | 5\n 6 | 7 | 8\nSpieler x, wo willst du setzen? 4\n x | o | 2 \n 3 | x | 5\n 6 | 7 | 8\nSpieler o, wo willst du setzen? 2\n x | o | o \n 3 | x | 5\n 6 | 7 | 8\nSpieler x, wo willst du setzen? 8\n x | o | o \n 3 | x | 5\n 6 | 7 | x\nHerzlichen Gl\u00fcckwunsch!\n</code></pre> <p>Wir haben bereits etwas Code vorgegeben. Dieser hat einige L\u00fccken, die wir f\u00fcllen m\u00fcssen.</p> <pre><code>def gameloop(): # (1)!\n    spielbrett = [0, 1, 2, 3, 4, 5, 6, 7, 8] # (14)!\n\n    aktiver_spieler = 'x' # (2)!\n    n\u00e4chster_spieler = 'o' # (3)!\n\n    while not es_gibt_gewinner(spielbrett): # (4)!\n        print(als_quadrat(spielbrett)) # (5)!\n\n        position = int(input(f\"Spieler {aktiver_spieler}, wo willst du setzen? \")) # (6)!\n\n        symbol_schreiben(spielbrett, position, aktiver_spieler) # (7)!\n\n        # Wechsle Spieler\n        ... # (8)!\n\n    print(als_quadrat(spielbrett)) # (9)!\n    print(f\"Herzlichen Gl\u00fcckwunsch!\") \n\n\ndef als_quadrat(spielbrett): # (10)!\n    return ...\n\ndef es_gibt_gewinner(spielbrett): # (11)!\n    return ...\n\ndef symbol_schreiben(spielbrett, position, symbol): # (12)!\n    ...\n\nif __name__ == '__main__': # (13)!\n    gameloop()\n</code></pre> <ol> <li>In der Funktion <code>gameloop</code> wird das gesamte Spiel durchgef\u00fchrt.</li> <li>In <code>aktiver_spieler</code> ist das Symbol des momentan aktiven Spielers gespeichert.</li> <li>In <code>n\u00e4chster_spieler</code> ist das Symbol gespeichert, dass der n\u00e4chste Spieler nutzt.</li> <li>In der Funktion <code>es_gibt_gewinner()</code> soll gepr\u00fcft werden, ob es schon einen Gewinner gibt. Wenn nein, so durchlaufen wir den Schleifenrumpf.</li> <li>Zun\u00e4chst geben wir das Spielfeld als sch\u00f6nes Quadrat (mithilfe der Methode <code>als_quadrat</code>) auf der Konsole aus. An den Zahlen erkennt der Spieler, welche Felder noch frei sind und was er in der Konsole eingeben muss, um in das richtige Feld zu setzen.</li> <li>Der Nutzer erh\u00e4lt die Aufforderung eine Zahl einzugeben, in welches das aktuelle Spielersymbol eingetragen wird. </li> <li>Auf dem Spielbrett wird nun an der vom Spieler gew\u00fcnschten Position das Zeichen gesetzt.</li> <li>Hier m\u00fcssen <code>aktiver_spieler</code> und <code>n\u00e4chster_spieler</code> wechseln.</li> <li>Wenn ein Gewinner gefunden wurde, wird die Schleife nicht l\u00e4nger durchlaufen und eine Gratulation wird angezeigt.</li> <li>Diese Funktion baut aus der Liste <code>[0, 1, ..., 8]</code> einen String mit Zeilenumbr\u00fcchen.</li> <li>Diese Funktion untersucht, ob es bereits einen Gewinner beim Tic Tac Toe spiel gibt. </li> <li>Diese Funktion erm\u00f6glicht es, in einer Liste (dem <code>spielbrett</code>) ein vorgegebenes <code>symbol</code> an einer bestimmten <code>position</code> zu setzen.</li> <li>Diese beiden Codezeilen sorgen daf\u00fcr, dass bei Ausf\u00fchrung der Datei das Programm gestartet wird.</li> <li>Das Spielbrett ist aus Sicht des Computers eine Liste mit neun Elementen. Mithilfe der Methode <code>als_quadrat</code>, werden wir dieses Spielbrett sp\u00e4ter auf der Konsole als ein sch\u00f6nes Quadrat ausgeben. Um das Spielfeld beim Programmieren einfacher zu handhaben, ist es hier aber gut, es als eine einfache Liste zu speichern.</li> </ol> <p>Wir m\u00fcssen in diesem Code vier Dinge erg\u00e4nzen:</p> Implementiere <code>als_quadrat</code> <p>Die Liste <code>spielbrett</code> soll auf der Konsole sch\u00f6n dargestellt werden.</p> <p>Beispiele</p> <p>F\u00fcr die Liste <code>[0, 1, 2, 3, 4, 5, 6, 7, 8]</code>: </p> <p><pre><code>0 | 1 | 2\n3 | 4 | 5\n6 | 7 | 8\n</code></pre> F\u00fcr die Liste <code>[\"x\", \"o\", 2, \"x\", 4, 5, 6, 7, \"o\"]</code>: </p> <pre><code>x | o | 2\nx | 4 | 5\n6 | 7 | o\n</code></pre> <p>Diese Darstellung wird in der Funktion <code>als_quadrat</code> erstellt. </p> <p>Mit <code>\\n</code> kann in einem String ein Zeilenumbruch gesetzt werden.</p> <p>Implementiere dies. Hier sind Unittests, mit denen du \u00fcberpr\u00fcfen kannst, ob deine Funktion richtig ist:</p> <pre><code>import unittest\n\n\ndef als_quadrat(spielbrett):\n    return ...\n\n\nclass TestAlsQuadrat(unittest.TestCase):\n    def test_als_quadrat_0(self):\n        spielbrett = [0, 1, 2, 3, 4, 5, 6, 7, 8]\n        erwartet = \"0 | 1 | 2\\n3 | 4 | 5\\n6 | 7 | 8\"\n        self.assertEqual(als_quadrat(spielbrett), erwartet)\n\n    def test_als_quadrat_1(self):\n        spielbrett = [\"x\", \"o\", 2, \"x\", 4, 5, 6, 7, \"o\"]\n        erwartet = \"x | o | 2\\nx | 4 | 5\\n6 | 7 | o\"\n        self.assertEqual(als_quadrat(spielbrett), erwartet)\n\nif __name__ == '__main__':\n    unittest.main()\n</code></pre> Tipp <p>Schreibe die Tests in eine seperate Datei. Wenn alles funktiniert, kopiere die korrekte Implementierung. Das ist zwar nicht die feine englische Art, aber f\u00fcr den Moment okay.</p> L\u00f6sung L\u00f6sungsvideo <p> </p> <pre><code>def als_quadrat(spielbrett):\n    return f\"{spielbrett[0]} | {spielbrett[1]} | {spielbrett[2]}\\n{spielbrett[3]} | {spielbrett[4]} | {spielbrett[5]}\\n{spielbrett[6]} | {spielbrett[7]} | {spielbrett[8]}\"\n</code></pre> Implementiere <code>es_gibt_gewinner</code> <p>Die Methode <code>es_gibt_gewinner</code> pr\u00fcft, ob in irgendeiner Zeile, Spalte oder Diagonalen ein Symbol drei mal auftaucht.</p> <p>Hier sind ein Haufen Unittests, mit denen du die Korrektheit deiner Funktion pr\u00fcfen kannst.</p> <pre><code>import unittest\n\n\ndef es_gibt_gewinner(spielbrett):\n  return ...\n\n\nclass TestEsGibtGewinner(unittest.TestCase):\n    def test_es_gibt_gewinner_alles_leer(self):\n        spielbrett = [0, 1, 2,\n                      3, 4, 5,\n                      6, 7, 8]\n        self.assertEqual(False, es_gibt_gewinner(spielbrett))\n\n    def test_es_gibt_gewinner_erste_zug(self):\n        spielbrett = [0, \"x\", 2,\n                      3, 4, 5,\n                      6, 7, 8]\n        self.assertEqual(False, es_gibt_gewinner(spielbrett))\n\n    def test_es_gibt_gewinner_zweiter_zug(self):\n        spielbrett = [0, \"x\", 2,\n                      3, \"o\", 5,\n                      6, 7, 8]\n        self.assertEqual(False, es_gibt_gewinner(spielbrett))\n\n    def test_es_gibt_gewinner_dritter_zug(self):\n        spielbrett = [0, \"x\", 2,\n                      3, \"o\", 5,\n                      6, \"x\", 8]\n        self.assertEqual(False, es_gibt_gewinner(spielbrett))\n\n    def test_es_gibt_gewinner_zeile_0(self):\n        spielbrett = [\"x\", \"x\", \"x\",\n                      \"o\", \"o\", 5,\n                      6, 7, 8]\n        self.assertEqual(True, es_gibt_gewinner(spielbrett))\n\n    def test_es_gibt_gewinner_zeile_1(self):\n        spielbrett = [\"x\", \"x\", \"o\",\n                      \"o\", \"o\", \"o\",\n                      6, 7, 8]\n        self.assertEqual(True, es_gibt_gewinner(spielbrett))\n\n    def test_es_gibt_gewinner_zeile_2(self):\n        spielbrett = [0, \"x\", \"o\",\n                      \"x\", \"o\", \"o\",\n                      \"x\", \"x\", \"x\"]\n        self.assertEqual(True, es_gibt_gewinner(spielbrett))\n\n    def test_es_gibt_gewinner_spalte_0(self):\n        spielbrett = [\"x\", 1, 2,\n                      \"x\", 4, 5,\n                      \"x\", 7, 8]\n        self.assertEqual(True, es_gibt_gewinner(spielbrett))\n\n    def test_es_gibt_gewinner_spalte_1(self):\n        spielbrett = [0, \"o\", 2,\n                      3, \"o\", 5,\n                      6, \"o\", 8]\n        self.assertEqual(True, es_gibt_gewinner(spielbrett))\n\n    def test_es_gibt_gewinner_spalte_2(self):\n        spielbrett = [0, 1, \"x\",\n                      3, 4, \"x\",\n                      6, 7, \"x\"]\n        self.assertEqual(True, es_gibt_gewinner(spielbrett))\n\n    def test_es_gibt_gewinner_diagonale_links_nach_rechts(self):\n        spielbrett = [\"x\", 1, 2,\n                      3, \"x\", 5,\n                      6, 7, \"x\"]\n        self.assertEqual(True, es_gibt_gewinner(spielbrett))\n\n    def test_es_gibt_gewinner_diagonale_rechts_nach_links(self):\n        spielbrett = [0, 1, \"x\",\n                      3, \"x\", 5,\n                      \"x\", 7, 8]\n        self.assertEqual(True, es_gibt_gewinner(spielbrett))\n\n    def test_es_gibt_gewinner_unentschieden(self):\n        spielbrett = [\"x\", \"o\", \"x\",\n                      \"x\", \"x\", \"o\",\n                      \"o\", \"x\", \"o\"]\n        self.assertEqual(False, es_gibt_gewinner(spielbrett))\n\nif __name__ == '__main__':\n    unittest.main()\n</code></pre> Tipp <p>\u00dcberlege dir zun\u00e4chst, wie du f\u00fcr die erste Zeile pr\u00fcften kannst, ob alle drei Symbole gleich sind.</p> <p>\u00dcberlege dir dann so eine Pr\u00fcfung f\u00fcr jede Zeile, Spalte und Diagonale.</p> <p>\u00dcberlege dir dann, wie du diese Bedingungen verkn\u00fcpfen kannst.</p> <p>Schreibe die Tests in eine seperate Datei. Wenn alles funktiniert, kopiere die korrekte Implementierung. Das ist zwar nicht die feine englische Art, aber f\u00fcr den Moment okay.</p> L\u00f6sung L\u00f6sungsvideo <p> </p> <pre><code>def es_gibt_gewinner(spielbrett):\n    return (spielbrett[0] == spielbrett[1] == spielbrett[2]\n            or spielbrett[3] == spielbrett[4] == spielbrett[5]\n            or spielbrett[6] == spielbrett[7] == spielbrett[8]\n            or spielbrett[0] == spielbrett[3] == spielbrett[6]\n            or spielbrett[1] == spielbrett[4] == spielbrett[7]\n            or spielbrett[2] == spielbrett[5] == spielbrett[8]\n            or spielbrett[0] == spielbrett[4] == spielbrett[8]\n            or spielbrett[2] == spielbrett[4] == spielbrett[6])\n</code></pre> Implementiere <code>symbol_schreiben</code> <p>In der Methode <code>symbol_schreiben</code> wird implementiert, wie ein neues Symbol auf das Spielfeld eingetragen wird. Implementiere dies. Hier sind Unittests, mit denen du \u00fcberpr\u00fcfen kannst, ob deine Funktion richtig ist:</p> <pre><code>import unittest\n\n\ndef symbol_schreiben(spilbrett, position, symbol):\n    ...\n\n\nclass TestSymbolSchreiben(unittest.TestCase):\n    def test_symbol_schreiben_0(self): # (1)!\n        spielbrett = [0, 1, 2, 3, 4, 5, 6, 7, 8] # (2)!\n        symbol = \"x\" # (3)!\n        position = 4 # (4)!\n        erwartet = [0, 1, 2, 3, \"x\", 5, 6, 7, 8] # (5)!\n        symbol_schreiben(spielbrett, position, symbol) # (6)!\n        self.assertEqual(spielbrett, erwartet) # (7)!\n\n    def test_symbol_schreiben_1(self):\n        spielbrett = [\"x\", \"o\", 2, \"x\", 4, 5, 6, 7, \"o\"]\n        symbol = \"o\"\n        position = 2\n        erwartet = [\"x\", \"o\", \"o\", \"x\", 4, 5, 6, 7, \"o\"]\n        symbol_schreiben(spielbrett, position, symbol)\n        self.assertEqual(spielbrett, erwartet)  \n\nif __name__ == '__main__':\n    unittest.main()\n</code></pre> <ol> <li>Der erste Test wird definiert.</li> <li>Das \"leere\" Spielfeld wird erstellt.</li> <li>Das Symbol wird festgelegt.</li> <li>Die Position wird festgelegt.</li> <li>Die erwartete L\u00f6sung wird definiert.</li> <li>Die Funktion wird ausgef\u00fchrt.</li> <li>Nun wird gepr\u00fcft, ob die liste <code>spielbrett</code> korrekt ge\u00e4ndert wurde.</li> </ol> Tipp <p>Schreibe die Tests in eine seperate Datei. Wenn alles funktioniert, kopiere die korrekte Implementierung. Das ist zwar nicht die feine englische Art, aber f\u00fcr den Moment okay.</p> L\u00f6sung L\u00f6sungsvideo <p> </p> <pre><code>def symbol_schreiben(spielbrett, position, symbol):\n    spielbrett[position] = symbol\n</code></pre> Implementiere den Spielerwechsel <p>Nach jedem Zug m\u00fcssen <code>aktiver_spieler</code> und <code>n\u00e4chster_spieler</code> wechseln. Dazu muss der Inhalt der Variable getauscht werden. F\u00fcge den Code in die Vorlage ein.</p> Tipp <p>Schaue dir die \u00dcbungsaufgabe Variableninhalte tauschen an.</p> L\u00f6sung L\u00f6sungsvideo <p> </p> <pre><code>def gameloop():\n    spielbrett = [0, 1, 2, 3, 4, 5, 6, 7, 8]\n\n    aktiver_spieler = 'x'\n    n\u00e4chster_spieler = 'o'\n    while not es_gibt_gewinner(spielbrett):\n        print(als_quadrat(spielbrett))\n\n        position = int(input(f\"Spieler {aktiver_spieler}, wo willst du setzen? \"))\n\n        symbol_schreiben(spielbrett, position, aktiver_spieler)\n\n        # Wechsle Spieler\n        zwischenspeicher = aktiver_spieler\n        aktiver_spieler = n\u00e4chster_spieler\n        n\u00e4chster_spieler = zwischenspeicher\n\n    print(als_quadrat(spielbrett))\n    print(f\"Herzlichen Gl\u00fcckwunsch!\")\n</code></pre> <p>Wenn wir alles richtig gemacht haben, kann so unsere L\u00f6sung aussehen:</p> Komplette L\u00f6sung <pre><code>import unittest\n\n\ndef gameloop():\n    spielbrett = [0, 1, 2, 3, 4, 5, 6, 7, 8]\n\n    aktiver_spieler = 'x'\n    n\u00e4chster_spieler = 'o'\n\n    while not es_gibt_gewinner(spielbrett):\n        print(als_quadrat(spielbrett))\n\n        position = int(input(f\"Spieler {aktiver_spieler}, wo willst du setzen? \"))\n\n        symbol_schreiben(spielbrett, position, aktiver_spieler)\n\n        # Wechsle Spieler\n        zwischenspeicher = aktiver_spieler\n        aktiver_spieler = n\u00e4chster_spieler\n        n\u00e4chster_spieler = zwischenspeicher\n\n    print(als_quadrat(spielbrett))\n    print(f\"Herzlichen Gl\u00fcckwunsch!\")\n\n\ndef als_quadrat(spielbrett):\n    return f\"{spielbrett[0]} | {spielbrett[1]} | {spielbrett[2]}\\n{spielbrett[3]} | {spielbrett[4]} | {spielbrett[5]}\\n{spielbrett[6]} | {spielbrett[7]} | {spielbrett[8]}\"\n\n\ndef es_gibt_gewinner(spielbrett):\n    return (spielbrett[0] == spielbrett[1] == spielbrett[2]\n            or spielbrett[3] == spielbrett[4] == spielbrett[5]\n            or spielbrett[6] == spielbrett[7] == spielbrett[8]\n            or spielbrett[0] == spielbrett[3] == spielbrett[6]\n            or spielbrett[1] == spielbrett[4] == spielbrett[7]\n            or spielbrett[2] == spielbrett[5] == spielbrett[8]\n            or spielbrett[0] == spielbrett[4] == spielbrett[8]\n            or spielbrett[2] == spielbrett[4] == spielbrett[6])\n\n\ndef symbol_schreiben(spielbrett, position, symbol):\n    spielbrett[position] = symbol\n\n\nclass TestAlsQuadrat(unittest.TestCase):\n    def test_als_quadrat_0(self):\n        spielbrett = [0, 1, 2, 3, 4, 5, 6, 7, 8]\n        erwartet = \"0 | 1 | 2\\n3 | 4 | 5\\n6 | 7 | 8\"\n        self.assertEqual(als_quadrat(spielbrett), erwartet)\n\n    def test_als_quadrat_1(self):\n        spielbrett = [\"x\", \"o\", 2, \"x\", 4, 5, 6, 7, \"o\"]\n        erwartet = \"x | o | 2\\nx | 4 | 5\\n6 | 7 | o\"\n        self.assertEqual(als_quadrat(spielbrett), erwartet)\n\n\nclass TestEsGibtGewinner(unittest.TestCase):\n    def test_es_gibt_gewinner_alles_leer(self):\n        spielbrett = [0, 1, 2,\n                      3, 4, 5,\n                      6, 7, 8]\n        self.assertEqual(False, es_gibt_gewinner(spielbrett))\n\n    def test_es_gibt_gewinner_erste_zug(self):\n        spielbrett = [0, \"x\", 2,\n                      3, 4, 5,\n                      6, 7, 8]\n        self.assertEqual(False, es_gibt_gewinner(spielbrett))\n\n    def test_es_gibt_gewinner_zweiter_zug(self):\n        spielbrett = [0, \"x\", 2,\n                      3, \"o\", 5,\n                      6, 7, 8]\n        self.assertEqual(False, es_gibt_gewinner(spielbrett))\n\n    def test_es_gibt_gewinner_dritter_zug(self):\n        spielbrett = [0, \"x\", 2,\n                      3, \"o\", 5,\n                      6, \"x\", 8]\n        self.assertEqual(False, es_gibt_gewinner(spielbrett))\n\n    def test_es_gibt_gewinner_zeile_0(self):\n        spielbrett = [\"x\", \"x\", \"x\",\n                      \"o\", \"o\", 5,\n                      6, 7, 8]\n        self.assertEqual(True, es_gibt_gewinner(spielbrett))\n\n    def test_es_gibt_gewinner_zeile_1(self):\n        spielbrett = [\"x\", \"x\", \"o\",\n                      \"o\", \"o\", \"o\",\n                      6, 7, 8]\n        self.assertEqual(True, es_gibt_gewinner(spielbrett))\n\n    def test_es_gibt_gewinner_zeile_2(self):\n        spielbrett = [0, \"x\", \"o\",\n                      \"x\", \"o\", \"o\",\n                      \"x\", \"x\", \"x\"]\n        self.assertEqual(True, es_gibt_gewinner(spielbrett))\n\n    def test_es_gibt_gewinner_spalte_0(self):\n        spielbrett = [\"x\", 1, 2,\n                      \"x\", 4, 5,\n                      \"x\", 7, 8]\n        self.assertEqual(True, es_gibt_gewinner(spielbrett))\n\n    def test_es_gibt_gewinner_spalte_1(self):\n        spielbrett = [0, \"o\", 2,\n                      3, \"o\", 5,\n                      6, \"o\", 8]\n        self.assertEqual(True, es_gibt_gewinner(spielbrett))\n\n    def test_es_gibt_gewinner_spalte_2(self):\n        spielbrett = [0, 1, \"x\",\n                      3, 4, \"x\",\n                      6, 7, \"x\"]\n        self.assertEqual(True, es_gibt_gewinner(spielbrett))\n\n    def test_es_gibt_gewinner_diagonale_links_nach_rechts(self):\n        spielbrett = [\"x\", 1, 2,\n                      3, \"x\", 5,\n                      6, 7, \"x\"]\n        self.assertEqual(True, es_gibt_gewinner(spielbrett))\n\n    def test_es_gibt_gewinner_diagonale_rechts_nach_links(self):\n        spielbrett = [0, 1, \"x\",\n                      3, \"x\", 5,\n                      \"x\", 7, 8]\n        self.assertEqual(True, es_gibt_gewinner(spielbrett))\n\n    def test_es_gibt_gewinner_unentschieden(self):\n        spielbrett = [\"x\", \"o\", \"x\",\n                      \"x\", \"x\", \"o\",\n                      \"o\", \"x\", \"o\"]\n        self.assertEqual(False, es_gibt_gewinner(spielbrett))\n\nclass TestSymbolSchreiben(unittest.TestCase):\n    def test_symbol_schreiben_0(self):\n        spielbrett = [0, 1, 2, 3, 4, 5, 6, 7, 8]\n        symbol = \"x\"\n        position = 4\n        erwartet = [0, 1, 2, 3, \"x\", 5, 6, 7, 8]\n        symbol_schreiben(spielbrett, position, symbol)\n        self.assertEqual(spielbrett, erwartet)\n\n    def test_symbol_schreiben_1(self):\n        spielbrett = [\"x\", \"o\", 2, \"x\", 4, 5, 6, 7, \"o\"]\n        symbol = \"o\"\n        position = 2\n        erwartet = [\"x\", \"o\", \"o\", \"x\", 4, 5, 6, 7, \"o\"]\n        symbol_schreiben(spielbrett, position, symbol)\n        self.assertEqual(spielbrett, erwartet)\n\n\nif __name__ == '__main__':\n    # unittest.main() # kommentar entfernen, um Methoden zu testen\n    gameloop()\n</code></pre> Video <p> </p>"},{"location":"content/quiz/quiz/","title":"Quiz","text":"<p>Hier findest du das Abschlussquiz der Schulung:</p> <p>Quiz</p> <p>Wir w\u00fcnschen dir viel Erfolg und danken dir f\u00fcr deine Teilnahme an der Schulung!\ud83d\udc9b</p>"},{"location":"content/unit_tests/unit_tests/","title":"Unit Tests","text":"<p>Code ist ein lebendiges Produkt. Das hei\u00dft, einmal geschrieben, bleibt eine Codebasis nie so wie sie ist.  Fehler m\u00fcssen korrigiert oder neue Features hinzugef\u00fcgt werden, die Anwendungsfreundlichkeit soll gesteigert werden oder die Laufzeit durch kl\u00fcgere Algorithmen verbessert werden. Es gibt viele Gr\u00fcnde, warum sich Code des selben Programms im Laufe der Zeit \u00e4ndert, aber wie stellt man sicher, dass bei \u00c4nderungen (gro\u00df oder klein) alles weiterhin funktioniert?</p> <p>Eine Antwort auf diese Frage sind Unittests. Diese werden von den Programmierern parallel (oder vor dem  eigentlichen Code) geschrieben und werden zuk\u00fcnftig immer ausgef\u00fchrt, wenn es eine \u00c4nderung im Code gibt. Diese Unittests \u00fcberpr\u00fcfen dann n\u00e4mlich, ob die einzelnen Bausteine meines Codes (die \"Units\"/Einheiten) immer noch funktionieren, oder ob irgendetwas durch die \u00c4nderungen gest\u00f6rt wurde.</p> <p>In einer Metapher gesprochen: Ein Restaurantbesitzer m\u00f6chte die K\u00fcche renovieren. Er l\u00e4sst von den K\u00f6chen eine lange Liste von Tests erstellen. Z.B. \"Es gibt Kochl\u00f6ffel\"; \"Die Herdplatte wird hei\u00df, wenn man  daran dreht\"; \"Der Eisschrank kann eine Temperatur von -17 \u00b0C halten\" usw. Alle diese Tests funktionieren bisher und das m\u00fcssen sie auch, wenn die neue K\u00fcche eingebaut ist. In der neuen K\u00fcche kommen noch neue Ger\u00e4te hinzu und auch f\u00fcr diese w\u00fcrde man weitere Tests der Liste hinzuf\u00fcgen, um alles f\u00fcr die Zukunft zu sichern.</p> Video <p> </p> <p>Betrachten wir das folgende Beispiel, in dem die Korrektheit der <code>quadrat</code> Funktion getestet wird. Wir sehen hier vier Tests, die pr\u00fcfen, ob </p> <ul> <li><code>quadrat(5) == 25</code>,</li> <li><code>quadrat(0) == 0</code>,</li> <li><code>quadrat(1) == 1</code> und</li> <li><code>quadrat(-5) == 25</code> gelten.</li> </ul> <pre><code>import unittest # (1)!\n\ndef quadrat(zahl): # (2)!\n    return zahl * zahl\n\n\nclass TestQuadrat(unittest.TestCase): # (3)!\n    def test_quadrat_0(self): # (4)!\n        self.assertEqual(quadrat(5), 25) # (5)!\n\n    def test_quadrat_1(self): # (6)!\n        self.assertEqual(quadrat(0), 0)\n\n    def test_quadrat_2(self):\n        self.assertEqual(quadrat(1), 1)\n\n    def test_quadrat_3(self):\n        self.assertEqual(quadrat(-5), 25)\n\nif __name__ == '__main__': # (7)!\n    unittest.main()\n</code></pre> <ol> <li>Wir importieren hier das Modul <code>unittest</code>. Das ist ein Ordner mit Pythoncode, den wir nun verwenden k\u00f6nnen. In diesem sind die Unittests implementiert und wir k\u00f6nnen diese jetzt in unserem Code definieren und ausf\u00fchren.</li> <li>Hier wird die Funktion definiert, die wir testen wollen.</li> <li>Hier wird eine Klasse namens <code>TestQuadrat</code> definiert, welche von <code>unittest.TestCase</code> erbt. Kurz gesagt bedeutet das, dass wir im nun folgenden einger\u00fcckten Code Methoden definieren k\u00f6nnen, die unsere Unittests sind.</li> <li>Hier wird ein Unittest definiert. Das sieht so \u00e4hnlich aus wie das Definieren einer Funktion. In die runden Klammern geh\u00f6rt immer der Parameter <code>self</code>, \u00fcber den wir die Art des Tests festlegen werden.Die genaue Bedeutung von <code>self</code> wird erst bei der objektorientierten Programmierung wichtig und kann jetzt erstmal von uns hingenommen werden.</li> <li>Mit <code>self.assertEqual( ... , ... )</code> wird gesagt, dass wir im Test sicherstellen (assert), dass zwei Werte gleich sind. Hier wollen wir sicherstellen, dass das Ergebnis von <code>quadrat(5)</code> gleich <code>25</code> ist. </li> <li>Wir definieren hier noch weitere Tests. Wichtig ist, dass deren Namen mit <code>test_</code> beginnen.</li> <li>In diesen zwei Zeilen sorgen wir daf\u00fcr, dass die Tests beim Ausf\u00fchren der Datei gefunden und ausgef\u00fchrt werden. Mehr m\u00fcssen wir hier zu diesem Zeitpunkt nicht verstehen.</li> </ol> <p>Wenn wir dieses Programm ausf\u00fchren erhalten wir die folgende Konsolenausgabe, die uns zeigt,  dass alle Tests erfolgreich waren:</p> <pre><code>Ran 4 tests in 0.012s\n\nOK\n\nProcess finished with exit code 0\n</code></pre> Fehlschlagende Tests <p>F\u00fchre den Code aus dem letzten Beispiel in deiner IDE aus und versichere dich, dass alle Tests funktionieren.</p> <p>\u00c4nder dann den Code, indem du z.B. den Rumpf der Methode <code>quadrat</code> anpasst, sodass die Tests nicht mehr  funktionieren.</p> Preisberechnung aktualisieren <p>J\u00fcrgen nutzt den folgenden Code, um den Eintritt in seinen Eisenbahnpark zu berechnen:</p> <pre><code>def berechne_preis(alter, mitglied):\n    if mitglied:\n        return 0\n    if alter &lt; 4:\n        return 0\n    if alter &gt; 60:\n        return 0\n    return 2    \n</code></pre> <p>J\u00fcrgen hat auch Tests geschrieben, um sicherzustellen, dass sein Code funktioniert:</p> <pre><code>import unittest  \n\nclass TestPreise(unittest.TestCase):\n    def test_berechne_preis_mitglied(self):\n        self.assertEqual(berechne_preis(20, True), 0)\n\n    def test_berechne_preis_kinder(self):\n        self.assertEqual(berechne_preis(2, False), 0)\n\n    def test_berechne_preis_retner(self):\n        self.assertEqual(berechne_preis(70, False), 0)\n\n    def test_berechne_preis_normal(self):\n        self.assertEqual(berechne_preis(20, False), 2)\n\nif __name__ == '__main__':\n    unittest.main()\n</code></pre> <p>Alle seine Tests funktionieren.</p> <p>J\u00fcrgen hat nun kennengelernt, wie man Bedingungen mit <code>or</code>, <code>and</code> und <code>not</code> miteinander verkn\u00fcpft und  m\u00f6chte nun seine Funktion etwas schlanker neu programmieren.</p> <p>Passe die Funktion von J\u00fcrgen an und achte dabei darauf, dass die Tests immer noch funktionieren!</p> Tipp <p>Der folgende Code</p> <pre><code>if bedingung1:\n    return x\nif bedingung2:\n    return x\n</code></pre> <p>kann so zusammengefasst werden:</p> <pre><code>if bedingung1 or bedingung2:\n    return x\n</code></pre> L\u00f6sung L\u00f6sungsvideo <p> </p> <pre><code>def berechne_preis(alter, mitglied):\n    if mitglied or alter &lt; 4 or alter &gt; 60:\n        return 0\n    return 2    \n</code></pre> Drei Gleich <p>Wir wollen eine Funktion entwickeln, die pr\u00fcft, ob in einer Liste die Elemente an drei Positionen gleich sind. Der Methodenkopf sieht wie folgt aus:</p> <pre><code>def drei_gleich(liste, pos0, pos1, pos2):\n    return ...\n</code></pre> <p>Hier haben wir schon einige Tests vorbereitet:</p> <pre><code>import unittest  \n\nclass TestDreiGleich(unittest.TestCase):\n    def test_drei_gleich_0(self):\n        self.assertEqual(drei_gleich([1, 1, 1], 0, 1, 2), True)\n\n    def test_drei_gleich_1(self):\n        self.assertEqual(drei_gleich([1, 2, 1, 3, 1], 0, 2, 4), True)\n\n    def test_drei_gleich_2(self):\n        self.assertEqual(drei_gleich([1, 2, 1, 3, 1], 0, 1, 2), False)\n\n    def test_drei_gleich_3(self):\n        self.assertEqual(drei_gleich([1, 1, 2], 0, 1, 2), False)\n\n\nif __name__ == '__main__':\n    unittest.main()\n</code></pre> <p>Implementiere die Funktion, sodass alle Tests gr\u00fcn werden.</p> Tipp <ul> <li>Mit der Notation <code>my_list[pos]</code> kann in einer Liste auf das Element an der Stelle <code>pos</code> zugegriffen werden.</li> <li>Mit <code>a == b</code> kann man \u00fcberpr\u00fcfen, ob zwei Elemente gleich sind.</li> <li>Mit <code>a == b == c</code> kann man pr\u00fcfen, ob drei Elemente gleich sind.</li> </ul> L\u00f6sung L\u00f6sungsvideo <p> </p> <pre><code>def drei_gleich(liste, pos0, pos1, pos2):\n    return liste[pos0] == liste[pos1] == liste[pos2]\n</code></pre>"},{"location":"content/variables/datentypen/","title":"Datentypen","text":"Video <p>Die Daten, die in einer Variable gespeichert sind, haben einen Typ. In Python ist dies wichtig, um zu wissen, was man mit den Daten eigentlich tun kann. Zahlen zum Beispiel kann man multiplizieren und addieren. Zeichenketten kann man miteinander zu l\u00e4ngeren Zeichenketten verbinden (1).</p> <ol> <li>Der Fachbegriff f\u00fcr das Verkn\u00fcpfen zweier Zeichenketten zu einem gr\u00f6\u00dferen hei\u00dft \"konkatenieren\".</li> </ol> <p>Eigentlich gibt es in Python eine ganze Reihe von Datentypen und man kann sogar eigene definieren. Wir wollen hier jedoch nur vier Datentypen vorstellen, die f\u00fcr diese Schulung von uns von Bedeutung sind:</p> Datentyp Englisch Deutsch Beispiele <code>int</code> Integer Ganzzahlen <code>0</code>, <code>1</code>, <code>-1</code>, <code>12353</code>, ... <code>float</code> Float Flie\u00dfkommazahlen <code>1.23</code>, <code>0.0001</code>, <code>1234.5</code>, <code>0.0</code>, ... <code>str</code> String Zeichenketten <code>'Hallo'</code>, <code>\"Menschen\"</code>, <code>'''mehrzeilige Strings'''</code>, ... <code>bool</code> Boolean Bin\u00e4re Wahrheitswerte <code>True</code>, <code>False</code> <p>Noch ein paar Zusatzinformationen:</p> IntegerFloatStringBoolean <p>In Python k\u00f6nnen Ganzzahlen beliebig gro\u00df bzw. klein werden. Das ist sehr angenehm, da man mit ihnen also sicher addieren, subtrahieren, multiplizieren und ganz-zahl-dividieren (<code>%</code> bzw <code>//</code>) kann, ohne dass man sich verrechnet, weil man den Raum der Ganzen Zahlen verl\u00e4sst.</p> <p><code>int</code> und <code>float</code> kannst du immer daran unterscheiden, dass bei <code>float</code> ein <code>.</code> in der Darstellung der Zahl ist:</p> <pre><code>a = 1 # a speichert einen int\nb = 1.0 # b speichert einen float\n</code></pre> <p>Es gibt unendlich viele Zahlen mit Stellen nach dem Komma. Und schlimmer noch: Zischen zwei verschiedenen Kommazahlen gibt es immer eine, die dazwischen liegt! Da wir au\u00dferdem noch f\u00fcr jede Kommazahl nur den gleichen endlichen Speicherplatz zur Verf\u00fcgung stellen um sie zu speichern, egal wie gro\u00df sie ist (<code>1</code> zu speichern verbraucht genau so viel Speicher wie <code>1000000</code>), ist das Speichern von Kommazahlen ein echtes Problem.</p> <p>In Python erm\u00f6glicht der Datentyp <code>float</code> das Speichern von Kommazahlen, jedoch nicht perfekt:</p> <ul> <li>Nicht jede Kommazahl ist exakt darstellbar.</li> <li>Es gibt (aus Sicht von Python) eine gr\u00f6\u00dfte und eine kleinste Flie\u00dfkommazahl</li> <li>Wenn zwei Kommazahlen addiert/multipliziert/... werden, kann es zu Rechenfehlern kommen. </li> </ul> <p>Schau dir dieses Beispiel zum letzten Punkt an.</p> <p>Zeichenketten k\u00f6nnen sowohl mit doppelten, als auch mit einfachen Anf\u00fchrungsstrichen geschrieben werden.</p> <p>Der Datentyp Boolean hat genau diese zwei Auspr\u00e4gungen, denn er beschreibt den bin\u00e4ren Wahrheitsgehalt einer Aussage. Etwas stimmt, oder es stimmt nicht, da gibt es kein \"vielleicht\"!</p>"},{"location":"content/variables/nutzereingaben/","title":"Nutzereingaben","text":"Video <p>Mit der <code>print</code> Funktion k\u00f6nnen wir auf der Konsole eine Ausgabe erzeugen.</p> <p>Andererseits kann mit der Funktion <code>input</code> eine Eingabe des Nutzers auf der Konsole erwartet werden. Wenn die Funktion aufgerufen wird, wartet der Code so lange, bis eine Nutzereingabe get\u00e4tigt und mit Enter best\u00e4tigt wurde. Die Eingabe des Nutzers wird dann in einer Variablen gespeichert.</p> <pre><code>print('Sei gegr\u00fc\u00dft!')\nvorname = input('Wie hei\u00dft du?') # (1)!\nprint('Hallo') \nprint(vorname) # (2)!\n</code></pre> <ol> <li>Wenn <code>input</code> aufgerufen wird, sehen wir auf der Kommandozeile den Prompt <code>Wie hei\u00dft du?</code>. Das Programm wartet jetzt auf unsere Eingabe. Unsere Eingabe wird dann in der Variablen <code>vorname</code> gespeichert.</li> <li>Hier wird die Eingabe wieder auf der Konsole ausgegeben.</li> </ol> Nutzereingabe erwarten <p>Ersetze die <code>...</code> im folgenden Code so, dass in einer Variable <code>vorname</code> der Name des Nutzers gespeichert wird. Danach soll in der Variable <code>alter</code> das Alter des Nutzers gespeichert werden.</p> <pre><code>... = ...('Wie hei\u00dft du?')\n... = ...('Wie alt bist du?')\n</code></pre> L\u00f6sung L\u00f6sungsvideo <p> </p> <pre><code>vorname = input('Wie hei\u00dft du?')\nalter = input('Wie alt bist du?')\n</code></pre> Vorsicht beim Einlesen von Zahlen <p> </p> <p>Immer, wenn man Zahlen vom Nutzer einlesen will und mit diesem im Code rechnen m\u00f6chte, so muss man Python ganz explizit sagen, dass hier eine Zahl folgt. Verwenden sie daher folgenden Code:</p> <p>Bei Ganzzahlen nutze <code>int(input(...))</code>:</p> <pre><code>alter = int(input('Wie alt bist du?'))\nprint('In einem Jahr bist du:')\nprint(alter + 1)\n</code></pre> <p>Bei Flie\u00dfkommazahlen nutze <code>float(input(...))</code>:</p> <pre><code>preis = float(input('wie viel kostet das Produkt?'))\nprint('Die Mehrwehrsteuer des Produktes betr\u00e4gt:')\nprint(preis * 0.19)\n</code></pre> Marsgewicht mit Eingabe <p>Bei diesem Programm wird das Gewicht auf dem Mars berechnet.</p> <pre><code>gewicht = 65\nmars_faktor = 0.38\nmars_gewicht = gewicht * mars_faktor\nprint(f'Dein Marsgewicht: {mars_gewicht}') # (1)!\n</code></pre> <ol> <li> <p>Wenn eine Zeichenkette mit <code>f</code> beginnt, so kann man in geschweiften Klammern <code>{...}</code> Variablen einf\u00fcgen. Dadurch werden die Inhalte der Variablen ausgelesen und eingef\u00fcgt. </p> <p>Diese sog. formatierten Strings sind sehr n\u00fctzlich und werden oft verwendet.</p> </li> </ol> <p>\u00c4ndere das Programm, sodass der Nutzer sein eigenes Gewicht angeben kann.</p> L\u00f6sung L\u00f6sungsvideo <p> </p> <pre><code>gewicht = int(input('Was wiegst du?')) # a\nmars_faktor = 0.37\nmars_gewicht = gewicht * mars_faktor\nprint(f'Dein Marsgewicht: {mars_gewicht}')\n</code></pre> BMI berechnen <p>Erstelle das folgende Programm, welches den BMI einer Person berechnet.</p> <p>Der Nutzer soll seine K\u00f6rpergr\u00f6\u00dfe in Metern angeben (z.B. <code>1.80</code>) und sein Gewicht in kg (z.B. <code>90</code>)</p> <p>Der BMI wird mit folgender Formel berechnet:</p> \\[ \\text{BMI} = \\frac{\\text{Gewicht in kg}}{(\\text{K\u00f6rpergr\u00f6\u00dfe in m})^2} \\] <p>Gib anschlie\u00dfend den BMI in einer Nachricht aus (In diesem Beispiel \\(\\approx 27.78\\)).</p> Tipp <p>Eine Zahl zu Quadrieren hei\u00dft, sie mit sich selbst zu multiplizieren. Das hei\u00dft du kannst auch folgende Formel verwenden:</p> \\[ \\text{BMI} = \\frac{\\text{Gewicht in kg}}{(\\text{K\u00f6rpergr\u00f6\u00dfe in m}) \\cdot (\\text{K\u00f6rpergr\u00f6\u00dfe in m)}} \\] <p>Um zwei Zahlen in Python miteinander zu dividieren nutze <code>/</code>. Z.B. <code>a = 7 / 8</code>.</p> L\u00f6sung L\u00f6sungsvideo <p> </p> <pre><code>gewicht = float(input('Wieviel wiegst du in kg?'))\ngr\u00f6\u00dfe = float(input('Wieviel wiegst du in Metern?'))\n\nbmi = gewicht / (gr\u00f6\u00dfe * gr\u00f6\u00dfe)\n\nprint(f\"Dein BMI ist {bmi}\")\n</code></pre>"},{"location":"content/variables/variablen/","title":"Variablen","text":"Einf\u00fchrung in Variablen <p>In Python k\u00f6nnen wir Informationen in Variablen speichern.</p> <p>Man kann sich eine Variable vorstellen wie einen beschrifteten Schuhkarton in einem Schrank.  In so einen Schuhkarton kann man zu einem beliebigen Zeitpunkt...</p> <ul> <li>... etwas hineinlegen; </li> <li>... anschauen, was drin ist;</li> <li>... einen neuen Inhalt hineingeben und den bisherigen Inhalt dadurch austauschen.</li> </ul> <p>Genauso ist es auch bei Variablen.</p> <p>Schauen wir uns dazu den folgenden Code an:</p> <pre><code>a = 1 # (1)!\nprint(a) # (4)!\n\na = 2 # (2)!\nprint(a) # (5)!\n\na = a + 3 # (3)!\nprint(a) # (6)!\n</code></pre> <ol> <li>In der neuen Variable <code>a</code> ist initial der Wert <code>1</code> gespeichert.</li> <li>In der Variable <code>a</code> ist nun der Wert <code>2</code> gespeichert. Die <code>1</code> wird vergessen.</li> <li>Der Wert von <code>a</code> wird zun\u00e4chst ausgelesen und dann 3 dazuaddiert. Das Ergebnis (<code>5</code>) wird dann wieder in <code>a</code> gespeichert.</li> <li>Der Wert der Variable <code>a</code> wird ausgelesen und mit der <code>print</code>-Funktion auf der Konsole ausgegeben.</li> <li>Der Wert der Variable <code>a</code> wird ausgelesen und mit der <code>print</code>-Funktion auf der Konsole ausgegeben.</li> <li>Der Wert der Variable <code>a</code> wird ausgelesen und mit der <code>print</code>-Funktion auf der Konsole ausgegeben.</li> </ol> <p>Wir k\u00f6nnen uns das obige Beispiel nun noch einmal im Debugger ansehen:</p> <p>Code im Debugger</p> <p> </p> <p>'\"Das Gleichheitszeichen <code>=</code> bedeutet nicht \"ist gleich\" sondern \"ist nun\"!</p> <p>Das Gleichheitszeichen <code>=</code> in Python ist der sogenannte Zuordnungsoperator. Er dient dazu, Inhalte in einer Variablen zuzuordnen. Auf der linken Seite des <code>=</code> steht immer die Variable, in die wir etwas speichern wollen und auf der  rechten Seite, was wir in der Variablen speichern wollen.</p> <p>Am besten lie\u00dft man Zeilen wie <code>a = 2</code> als: \"<code>a</code> hat nun den Wert <code>2</code>.\"</p> <p>Es ist nicht der Gleichheitsoperator, wie wir ihn aus der Mathematik kennen.</p> <p> </p> Variablen anlegen <p>Ersetze die <code>...</code> im folgenden Code so, dass es eine Variable <code>vorname</code> mit dem Wert <code>'Hans'</code> und eine Variable <code>alter</code> mit dem Wert <code>32</code> gibt.</p> <pre><code>... = 'Hans'\n... = 32\n</code></pre> L\u00f6sung <pre><code>vorname = 'Hans'\nalter = 32\n</code></pre> <p>Auch folgende Notation ist m\u00f6glich:</p> <pre><code>vorname, alter = 'Hans', 32\n</code></pre> Variablenbef\u00fcllung voraussagen <p>Sag voraus, was auf der Konsole ausgegeben wird, wenn das Programm ausgef\u00fchrt wird.</p> <pre><code>a = 3\nb = 5\n\nprint(a)\nprint(b)\nprint(a+b)\n</code></pre> L\u00f6sung L\u00f6sungsvideo <p> </p> <pre><code>a = 3\nb = 5\n\nprint(a) # 3\nprint(b) # 5\nprint(a+b) # 8\n</code></pre> Variablenbef\u00fcllung voraussagen mit Falle <p>Sag voraus, was auf der Konsole ausgegeben wird, wenn das Programm ausgef\u00fchrt wird.</p> <pre><code>preis = 3\nprint(preis)\n\npreis = preis + 4\nprint(preis)\n\nprint(preis + 5)\n\nprint(preis)\n</code></pre> Tipp <p>Der Inhalt einer Variable wird nur dann neu bef\u00fcllt, wenn auch der Zuordnungsoperator <code>=</code> aufgerufen wird.</p> L\u00f6sung L\u00f6sungsvideo <p> </p> <pre><code>preis = 3\nprint(preis) # 3\n\npreis = preis + 4\nprint(preis) # 7\n\nprint(preis + 5) # 12\n\nprint(preis) # 7\n</code></pre> Variablenbef\u00fcllung voraussagen mit vielen Fallen <p>Sag voraus, was auf der Konsole ausgegeben wird, wenn das Programm ausgef\u00fchrt wird.</p> <pre><code>a = 3\nb = 2\nc = a + b\nb = a\na = a - b * c\n\nprint(a)\nprint(b)\nprint(c)\n</code></pre> Tipp <ul> <li>Erstelle eine Tabelle, in der du f\u00fcr jede Zeile sagst, welchen Wert jede Variable nach dieser Zeile hat:</li> </ul> Code a b c <code>a = 3</code> <code>b = 2</code> <code>c = a+b</code> <code>b = a</code> <code>a = a - b * c</code> <ul> <li> <p><code>b = a</code> bedeutet, dass <code>b</code> nun den Wert von <code>a</code> hat.</p> </li> <li> <p><code>*</code> beschreibt das Multiplizieren.</p> </li> <li> <p>Denke an die Punkt- vor Strichrechnung.</p> </li> </ul> L\u00f6sung L\u00f6sungsvideo <p> </p> Code a b c <code>a = 3</code> <code>3</code> <code>b = 2</code> <code>3</code> <code>2</code> <code>c = a+b</code> <code>3</code> <code>2</code> <code>5</code> <code>b = a</code> <code>3</code> <code>3</code> <code>5</code> <code>a = a - b * c</code> <code>-12</code> <code>3</code> <code>5</code> <p>Auf der Konsole erscheint: <pre><code>-12\n3\n5\n</code></pre></p> Variablenbenennung <p>In Python darf ein Variablenname nur aus Buchstaben, Ziffern und Unterstrichen bestehen. Und sie darf nicht mit einer Ziffer beginnen.</p> <p>Welche der folgenden sind erlaubte Variablennamen?</p> <ul> <li><code>name_1</code></li> <li><code>1name</code></li> <li><code>name!</code></li> <li><code>_alter</code></li> <li><code>Alter</code></li> <li><code>\u20acin$</code></li> <li><code>euro_in_dollar</code></li> <li><code>z</code></li> <li><code>_</code></li> <li><code>__init__</code></li> </ul> L\u00f6sung L\u00f6sungsvideo <p> </p> <ul> <li><code>name_1</code> \u2705</li> <li><code>1name</code> \u274c</li> <li><code>name!</code> \u274c</li> <li><code>_alter</code> \u2705</li> <li><code>Alter</code> \u2705</li> <li><code>\u20acin$</code> \u274c</li> <li><code>euro_in_dollar</code> \u2705</li> <li><code>z</code> \u2705</li> <li><code>_</code> \u2705</li> <li><code>__init__</code> \u2705</li> </ul> Variableninhalte tauschen <p>Ersetze die <code>...</code> im folgenden Code so, dass <code>preis_a</code> und <code>preis_b</code> den Inhalt austauschen.</p> <pre><code>preis_a = 10\npreis_b = 5\n\n...\n...\n...\n\nprint(preis_a) # 5\nprint(preis_b) # 10\n</code></pre> Tipp <p>Nutzen Sie eine Variable <code>z</code> als Zwischenspeicher.</p> L\u00f6sung L\u00f6sungsvideo <p> </p> <pre><code>preis_a = 10\npreis_b = 5\n\nz = preis_b\npreis_b = preis_a\npreis_a = z\n\nprint(preis_a) # 5\nprint(preis_b) # 10\n</code></pre> Marsgewicht <p>Erstelle das folgende Programm:</p> <ul> <li>In der Variable <code>gewicht</code> steht ein Gewicht (z.B. \\(65\\) kg)</li> <li>In einer zweiten Variable <code>mars_faktor</code> steht die Zahl <code>0.38</code>.</li> <li>In einer dritten Variable <code>mars_gewicht</code> soll das Gewicht auf dem Mars gespeichert werden. Dies wird berechnet, indem <code>gewicht</code> und <code>mars_faktor</code> miteinander multipliziert werden.</li> <li>Auf der Konsole soll nun das <code>mars_gewicht</code> ausgegeben werden (In diesem Beispiel \\(24.7\\)).</li> </ul> <p>Hier ist ein Schwerkraftrechner mit dem du dein Programm \u00fcberpr\u00fcfen kannst.</p> <p>\ud83d\ude80Bonus: Erweiter dein Programm gerne um weitere Planeten.</p> Tipp <p>Kommazahlen wie \\(0,38\\) werden in Python mit einem Punkt statt einem Komma geschrieben, also <code>0.38</code></p> <p>Um zwei Zahlen in Python miteinander zu multiplizieren nutzen sie <code>*</code>. Z.B. <code>a = 7 * 8</code>.</p> L\u00f6sung L\u00f6sungsvideo <p> </p> <pre><code>gewicht = 65\nmars_faktor = 0.38\nmars_gewicht = gewicht * mars_faktor\n</code></pre>"}]}